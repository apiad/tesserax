# Animation & Video

Tesserax isn't just for static images. It includes a lightweight, code-first animation engine capable of exporting GIFs and MP4s.

> **Note**: To use animation features, ensure you installed Tesserax with the export dependencies: `pip install tesserax[export]`.

## The `Scene` Object

The `Scene` is the director of your animation. It wraps a `Canvas` and manages the render loop, frame capture, and file export.

At its lowest level, you can animate simply by changing shapes in a loop and calling `scene.capture()`. This gives you total control over every frame.

```{python}
from tesserax import Canvas, Square, deg
from tesserax.animation import Scene
from tesserax.color import Colors

# 1. Setup the static scene
with Canvas() as canvas:
    rect = Square(40, fill=Colors.Orange)

canvas.fit(10)

# 2. Animate
scene = Scene(canvas, fps=30)

# We manually drive the loop
for i in range(30):
    rect.rotated(deg(3)) # Rotate 3 degrees per frame
    scene.capture()      # Snap!

# 3. Render
scene.display()
```

## Declarative Animations

While manual loops are powerful, they get messy quickly. Tesserax provides a declarative API where you define *what* happens, not *how*.

The `Scene.play()` method accepts one or more `Animation` objects.

* **Parallel**: Arguments passed to `play(a, b)` run **simultaneously**.
* **Sequential**: Animations added with `a + b` run **one after another**.

We use the `.animate` property on shapes to quickly generate these objects.

```{python}
from tesserax import Circle

with Canvas() as canvas:
    box = Square(30, fill=Colors.LightBlue).translated(-40, 0)
    ball = Circle(15, fill=Colors.Salmon).translated(40, 0)

canvas.fit(10)
scene = Scene(canvas, fps=30)

# Define animations
move_box = box.animate.rotate(deg(90)) | box.animate.translate(20)
fade_ball = ball.animate.scale(0.5)

# Run them together (box moves sequentially, ball scales in parallel)
scene.play(move_box.looping(), fade_ball.looping(), duration=2.0)

scene.display()
```

### Animation Modifiers

You can tweak the timing and behavior of any animation using fluent modifiers:

* `.reversed()`: Plays backwards.
* `.looping()`: Plays forward then backward (yoyo).
* `.repeating(n)`: Repeats `n` times within the duration.
* `.delayed(t)`: Waits for `t` (0.0 to 1.0) before starting.
* `.smoothed()`: Applies an ease-in-out curve (default is linear).

```{python}
from tesserax import Shape

with Canvas() as c:
    b1 = Circle(10, fill=Colors.Red).translated(-30, 0)
    b2 = Circle(10, fill=Colors.Blue).translated(0, 0)
    b3 = Circle(10, fill=Colors.Green).translated(30, 0)

c.fit(40)
scene = Scene(c)

# Create a jump animation
def jump(shape: Shape):
    return (
        shape.animate.translate(0, -40).smoothed() |
        shape.animate.translate(0, 0).smoothed()
    )

scene.play(
    jump(b1),
    jump(b2).delayed(0.2), # Start 20% later
    jump(b3).delayed(0.4), # Start 40% later
    duration=1.5
)

scene.display()
```

## Morphing and Warping

For `Polyline` shapes, Tesserax offers advanced vertex manipulation.

### Morphing

The `.morph(target)` animation smoothly interpolates the points of one shape into another.

```{python}
from tesserax import Polyline

with Canvas() as c:
    # Start as a Triangle
    shape = Polyline.poly(3, 40, fill=Colors.Gold).subdivide()
    # Target is a Hexagon
    target = Polyline.poly(6, 40).hide()

c.fit(10)
scene = Scene(c)

scene.play(
    shape.animate.morph(target).smoothed().looping(),
    duration=2.0
)

scene.display()
```

### Warping

The `.warp(func)` animation allows you to apply a function  to every point in a shape over time. This is perfect for wave effects.

```{python}
import math
from tesserax import Point

with Canvas() as c:
    # Create a dense line so we have points to warp
    line = Polyline([Point(x, 0) for x in range(-50, 50, 2)], stroke=Colors.Blue)

c.fit(15)
scene = Scene(c)

# Define a wave function
def wave(p, t):
    # t goes 0 -> 1
    # We use it to shift the phase
    phase = t * math.pi * 2
    amplitude = 10
    freq = 0.1
    return Point(p.x, math.sin(p.x * freq + phase) * amplitude)

scene.play(
    line.animate.warp(wave).repeating(2),
    duration=2.0
)

canvas.fit(10)
scene.display()
```

## Text Effects

Text objects have their own special animator with effects like `write` (typewriter style) and `scramble` (hacker style).

```{python}
from tesserax import Text

with Canvas() as c:
    t1 = Text("Hello World", size=24).translated(0, -20)
    t2 = Text("Encryption", size=24, fill=Colors.Green, font="monospace").translated(0, 20)

c.fit(10)
scene = Scene(c)

scene.play(
    t1.animate.write(),
    t2.animate.scramble(),
    duration=2.0
)
scene.wait(1.0)

scene.display()
```
