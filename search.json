[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Tesserax: A Lightweight SVG Rendering Library",
    "section": "",
    "text": "Tesserax is a modern Python 3.12 library designed for programmatic SVG generation with a focus on ease of use, layout management, and flexible geometric primitives. It is particularly well-suited for visualizing data structures, algorithms, and technical diagrams."
  },
  {
    "objectID": "index.html#key-features",
    "href": "index.html#key-features",
    "title": "Tesserax: A Lightweight SVG Rendering Library",
    "section": "Key Features",
    "text": "Key Features\n\nDeclarative Layouts: Effortlessly arrange shapes in Row or Column containers with automatic alignment and spacing.\nAnchor System: Connect shapes using semantic anchors like top, bottom, left, right, and center.\nContext Manager Support: Use with statements to group shapes naturally within the code.\nSmart Canvas: Automatically fit the canvas viewport to the content with adjustable padding.\nRich Primitives: Includes Rect, Square, Circle, Ellipse, Line, Arrow, and Path."
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "Tesserax: A Lightweight SVG Rendering Library",
    "section": "Installation",
    "text": "Installation\nTesserax has zero dependencies (literally). It’s 100% pure Python, and can be easily installed with pip:\npip install tesserax\nOr if you’re one of the cool kids, using uv:\nuv add tesserax"
  },
  {
    "objectID": "index.html#quick-start",
    "href": "index.html#quick-start",
    "title": "Tesserax: A Lightweight SVG Rendering Library",
    "section": "Quick Start",
    "text": "Quick Start\nThe following example demonstrates how to create two shapes in a row and connect them with an arrow using the anchor system.\n\n\nCode\nfrom tesserax import Canvas, Rect, Arrow, Circle\nfrom tesserax.layout import Row\n\n# Initialize a canvas\nwith Canvas() as canvas:\n    # Arrange a circle and a rectangle in a row with a 50px gap\n    with Row(gap=50):\n        circle = Circle(30, fill=\"#fee\")\n        rect = Rect(100, 60, fill=\"#eef\")\n\n    # Draw an arrow between the two shapes using anchors\n    # .dx() provides a small offset for better visual spacing\n    Arrow(\n        circle.anchor(\"right\").dx(5),\n        rect.anchor(\"left\").dx(-5)\n    )\n\n# Fit the viewport to the shapes and render\ncanvas.fit(padding=10).display()\n\n\n\n\n\n\n\n\n\nThe display() method in the Canvas class is an IPython/Jupyter/Quarto compatible shortcut to automatically include the rendered SVG (in all its beautiful vectorial glory) directly in a notebook. But you can also use Canvas.save() to generate a plain old, boring SVG file on this, and str(canvas) to get the actual SVG code as a plain string."
  },
  {
    "objectID": "index.html#core-components",
    "href": "index.html#core-components",
    "title": "Tesserax: A Lightweight SVG Rendering Library",
    "section": "Core Components",
    "text": "Core Components\nTesserax comes with all basic components you need to draw the spectrum of SVG shapes. All shapes support standard SVG attributes like stroke and fill.\n\nRect & Square: Defined by width/height or a single size.\nCircle & Ellipse: Defined by radii.\nGroups: For grouping shapes and applying transforms to them as a single shape.\nArrow: A specialized line that automatically includes an arrowhead marker.\nPath: Supports a fluent API for complex paths using move_to, line_to, cubic_to, and close.\n\n\nLayouts\nLayouts are a unique feature of Tesserax to automate the positioning of child elements. We currently have three layouts, but these are very easy to extend:\n\nRow: Aligns shapes horizontally. Baselines can be set to start, middle, or end.\nColumn: Aligns shapes vertically with start, middle, or end alignment.\nForceLayout: Typically used to draw graphs."
  },
  {
    "objectID": "index.html#transforms",
    "href": "index.html#transforms",
    "title": "Tesserax: A Lightweight SVG Rendering Library",
    "section": "Transforms",
    "text": "Transforms\nEvery shape has a Transform object allowing for:\n\nTranslation: shape.translated(dx, dy).\nRotation: shape.rotated(degrees).\nScaling: shape.scaled(factor).\n\nGroups of shapes also have their own transform, and this can be composed ad-infinitum to create complex drawing."
  },
  {
    "objectID": "index.html#developer-information",
    "href": "index.html#developer-information",
    "title": "Tesserax: A Lightweight SVG Rendering Library",
    "section": "Developer Information",
    "text": "Developer Information\nTesserax is built with modern Python 3.12 features, including:\n\nFully Typed: Comprehensive type hinting for better IDE support and safety.\nDeep Integration: Utilizes dataclasses for points and transforms and abc for extensible shape definitions."
  },
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "Tesserax",
    "section": "",
    "text": "This “Core Concepts” guide will walk you through building a scene from scratch, demonstrating how Tesserax handles shapes, positioning, and composition."
  },
  {
    "objectID": "core.html#the-canvas-and-the-first-shape",
    "href": "core.html#the-canvas-and-the-first-shape",
    "title": "Tesserax",
    "section": "The Canvas and the First Shape",
    "text": "The Canvas and the First Shape\nEvery drawing starts with a Canvas. In Tesserax, the Canvas acts as the root container and provides a context manager to automatically add shapes created within its block.\nWe will start by creating a simple 100x50 rectangle.\n\n\nCode\nfrom tesserax import Canvas, Rect\n\n# Initialize the canvas\nwith Canvas() as canvas:\n    # Adding our first shape\n    # Primitives support standard SVG attributes like fill\n    Rect(100, 50, fill=\"lightblue\")\n\n# fit() adjusts the viewport to the content\n# display() renders it directly in the documentation\ncanvas.fit(padding=10).display()"
  },
  {
    "objectID": "core.html#adding-and-transforming-shapes",
    "href": "core.html#adding-and-transforming-shapes",
    "title": "Tesserax",
    "section": "Adding and Transforming Shapes",
    "text": "Adding and Transforming Shapes\nWhile you can add shapes and manually set their coordinates, Tesserax provides a fluent API for transformations. Here, we add a Circle and use translated() to move it into position.\n\n\nCode\nfrom tesserax import Canvas, Rect, Circle\n\nwith Canvas() as canvas:\n    Rect(100, 50, fill=\"lightblue\")\n\n    # Adding a second shape and moving it manually\n    # Circle is defined by its radius\n    Circle(30, fill=\"salmon\").translated(150, 25)\n\ncanvas.fit(padding=10).display()"
  },
  {
    "objectID": "core.html#simplifying-with-layouts",
    "href": "core.html#simplifying-with-layouts",
    "title": "Tesserax",
    "section": "Simplifying with Layouts",
    "text": "Simplifying with Layouts\nManually calculating offsets (like the 150, 25 above) becomes tedious in complex diagrams. Layouts automate this positioning. The Row layout arranges its children horizontally with an optional gap.\n\n\nCode\nfrom tesserax import Canvas, Rect, Circle\nfrom tesserax.layout import Row\n\nwith Canvas() as canvas:\n    # Row is also a context manager\n    with Row(gap=20):\n        Rect(100, 50, fill=\"lightblue\")\n        Circle(30, fill=\"salmon\")\n\ncanvas.fit(padding=10).display()"
  },
  {
    "objectID": "core.html#composing-transforms-and-groups",
    "href": "core.html#composing-transforms-and-groups",
    "title": "Tesserax",
    "section": "Composing Transforms and Groups",
    "text": "Composing Transforms and Groups\nBecause Layouts are themselves a type of Group, you can apply transformations to the entire layout at once. In this step, we will:\n\nCreate a Row layout.\nRotate that entire row by 45 degrees.\nAdd a new shape outside of that row.\nWrap everything in another Group to demonstrate hierarchical composition.\n\n\n\nCode\nfrom tesserax import Canvas, Rect, Circle, Group\nfrom tesserax.layout import Row\n\nwith Canvas() as canvas:\n    # Create and rotate a layout\n    with Row(gap=20).rotated(45):\n        Rect(100, 50, fill=\"lightblue\")\n        Circle(30, fill=\"salmon\")\n\n    # Add another shape to the scene\n    Rect(40, 40, fill=\"lightgreen\").translated(100, -50)\n\n    # All shapes here are already part of the Canvas group.\n\ncanvas.fit(padding=10).display()\n\n\n\n\n\n\n\n\n\nBy nesting Layouts and Groups, you can build extremely complex diagrams without ever having to manually compute a single SVG coordinate string."
  },
  {
    "objectID": "core.html#bridging-contexts-with-anchors",
    "href": "core.html#bridging-contexts-with-anchors",
    "title": "Tesserax",
    "section": "Bridging Contexts with Anchors",
    "text": "Bridging Contexts with Anchors\nOne of the most powerful features of Tesserax is the Anchor System. When you place a shape inside a Layout or a Group, its local coordinates change to reflect its position within that container. However, Tesserax allows you to retrieve the “global” position of a shape’s anchors, making it trivial to connect objects across different coordinate systems.\nIn this example, we will connect the Circle (which is inside a rotated Row) to the Rect (which is outside) using an Arrow, and the two shapes inside the row.\n\n\nCode\nfrom tesserax import Canvas, Rect, Circle, Arrow\nfrom tesserax.layout import Row\n\nwith Canvas() as canvas:\n    # 1. Create a Row and rotate it\n    with Row(gap=40) as row:\n        r1 = Rect(80, 40, fill=\"aliceblue\")\n        c1 = Circle(30, fill=\"mistyrose\")\n\n    row.rotated(30).translated(50, 50)\n\n    # 2. Create a target rectangle outside the layout\n    target = Rect(60, 60, fill=\"honeydew\").translated(250, 0)\n\n    # 3. Connect them!\n    # We use .anchor() to get semantic points.\n    # Even though c1 is inside a rotated row, c1.anchor(\"right\")\n    # returns the correct global coordinate for the arrow.\n    Arrow(\n        c1.anchor(\"top\").dy(5),\n        target.anchor(\"left\").dx(-5),\n        stroke=\"grey\",\n        width=2,\n    )\n\n    Arrow(\n        r1.anchor(\"right\").dx(5),\n        c1.anchor(\"left\").dx(-5),\n        stroke=\"grey\",\n        width=2,\n    )\n\ncanvas.fit(padding=10).display()\n\n\n\n\n\n\n\n\n\n\nHow Coordinate Mapping Works\nWhen you call shape.anchor(name), Tesserax performs the following behind the scenes:\n\nLocal Geometry: It identifies the point on the shape (e.g., the rightmost edge of the Circle).\nTransformation Path: It traverses up the hierarchy (from the Circle to the Row, then to the Canvas), applying every rotation, scale, and translation encountered along the way.\nGlobal Result: It returns a Point that represents exactly where that anchor sits on the final SVG canvas.\n\nThis means you never have to manually calculate sin() or cos() to find where a rotated object’s edge is located—you just ask for the anchor.\nFor explicit anchoring, you can use Shape.resolve(p: Point) to map a point in local space to the global space, this way you can, e.g., get the point at 2/3rds of the way inside a rectangle and map it to global space."
  }
]