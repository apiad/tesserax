[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Tesserax: A Lightweight SVG Rendering Library",
    "section": "",
    "text": "Tesserax is a modern Python 3.12 library designed for programmatic SVG generation with a focus on ease of use, layout management, and flexible geometric primitives. It is particularly well-suited for visualizing data structures, algorithms, and technical diagrams."
  },
  {
    "objectID": "index.html#key-features",
    "href": "index.html#key-features",
    "title": "Tesserax: A Lightweight SVG Rendering Library",
    "section": "Key Features",
    "text": "Key Features\n\nDeclarative Layouts: Effortlessly arrange shapes in Row or Column containers with automatic alignment and spacing.\nAnchor System: Connect shapes using semantic anchors like top, bottom, left, right, and center.\nContext Manager Support: Use with statements to group shapes naturally within the code.\nSmart Canvas: Automatically fit the canvas viewport to the content with adjustable padding.\nRich Primitives: Includes Rect, Square, Circle, Ellipse, Line, Arrow, and Path."
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "Tesserax: A Lightweight SVG Rendering Library",
    "section": "Installation",
    "text": "Installation\nTesserax has zero dependencies (literally). It’s 100% pure Python, and can be easily installed with pip:\npip install tesserax\nOr if you’re one of the cool kids, using uv:\nuv add tesserax\nIf you want support for saving PNG files, install with the export extra:\npip install tesserax[export]"
  },
  {
    "objectID": "index.html#quick-start",
    "href": "index.html#quick-start",
    "title": "Tesserax: A Lightweight SVG Rendering Library",
    "section": "Quick Start",
    "text": "Quick Start\nThe following example demonstrates how to create two shapes in a row and connect them with an arrow using the anchor system.\n\n\nCode\nfrom tesserax import Canvas, Rect, Arrow, Circle\nfrom tesserax.layout import Row\n\n# Initialize a canvas\nwith Canvas() as canvas:\n    # Arrange a circle and a rectangle in a row with a 50px gap\n    with Row(gap=50):\n        circle = Circle(30, fill=\"#fee\")\n        rect = Rect(100, 60, fill=\"#eef\")\n\n    # Draw an arrow between the two shapes using anchors\n    # .dx() provides a small offset for better visual spacing\n    Arrow(\n        circle.anchor(\"right\").dx(5),\n        rect.anchor(\"left\").dx(-5)\n    )\n\n# Fit the viewport to the shapes and render\ncanvas.fit(padding=10).display()\n\n\n\n\n\n\n\n\n\nThe display() method in the Canvas class is an IPython/Jupyter/Quarto compatible shortcut to automatically include the rendered SVG (in all its beautiful vectorial glory) directly in a notebook. But you can also use Canvas.save() to generate a plain old, boring SVG file on this, and str(canvas) to get the actual SVG code as a plain string."
  },
  {
    "objectID": "index.html#core-components",
    "href": "index.html#core-components",
    "title": "Tesserax: A Lightweight SVG Rendering Library",
    "section": "Core Components",
    "text": "Core Components\nTesserax comes with all basic components you need to draw the spectrum of SVG shapes. All shapes support standard SVG attributes like stroke and fill.\n\nRect & Square: Defined by width/height or a single size.\nCircle & Ellipse: Defined by radii.\nGroups: For grouping shapes and applying transforms to them as a single shape.\nArrow: A specialized line that automatically includes an arrowhead marker.\nPath: Supports a fluent API for complex paths using move_to, line_to, cubic_to, and close.\n\n\nLayouts\nLayouts are a unique feature of Tesserax to automate the positioning of child elements. We currently have three layouts, but these are very easy to extend:\n\nRow: Aligns shapes horizontally. Baselines can be set to start, middle, or end.\nColumn: Aligns shapes vertically with start, middle, or end alignment.\nHierarchicalLayout: Useful for drawing trees, DAGs, automata, etc.\nForceLayout: Typically used to draw arbitrary graphs with a force-directed algorithm.\n\n\n\nTransforms\nEvery shape has a Transform object allowing for:\n\nTranslation: shape.translated(dx, dy).\nRotation: shape.rotated(degrees).\nScaling: shape.scaled(factor).\n\nGroups of shapes also have their own transform, and this can be composed ad-infinitum to create complex drawing."
  },
  {
    "objectID": "index.html#why-tesserax",
    "href": "index.html#why-tesserax",
    "title": "Tesserax: A Lightweight SVG Rendering Library",
    "section": "Why Tesserax?",
    "text": "Why Tesserax?\nIn the Python ecosystem, there is a clear divide between data visualization (plotting numbers) and diagrammatic representation (drawing concepts). Tesserax is built for the latter.\nIt is designed for researchers, educators, and authors who need the geometric precision of a professional drafting tool combined with the power of a modern programming language.\n\nTesserax vs. The Alternatives\n\nPrecision over Statistics\nLibraries like Matplotlib, Seaborn, or Altair are designed to map data points to visual encodings (bars, lines, scatter points).\nThe Difference: Tesserax does not compete with these libraries because it does not render data graphs. You wouldn’t use Tesserax to plot a CSV. Instead, Tesserax is for “the rest” of the figures in a paper: the schematics, the geometric proofs, the architectural diagrams, and the algorithmic walkthroughs where exact spatial relationships convey the meaning.\n\n\nControl over Constraints\nMermaid and Graphviz are excellent for quickly rendering flowcharts using “black-box” layout engines.\nThe Difference: These tools sacrifice control for convenience. If you need an arrow to point exactly at the tangent of a rotated ellipse, or a shape to be sized exactly according to a geometric ratio, Mermaid cannot help you. Tesserax is for Scientific Drawing—providing the low-level primitives needed for total layout authority.\n\n\nThe “TikZ for Python” Philosophy\nTikZ is the industry standard for academic figures, but it requires learning a specialized, often cryptic macro language.\nThe Difference: Tesserax brings the “low-level, total-control” philosophy of TikZ into Python 3.12. You get coordinate-invariant precision and semantic anchoring while using Python’s loops, logic, and types. We are building from the bottom up: starting with geometric atoms and moving toward high-level scientific abstractions (like automated neural network architectures or commutative diagrams) that maintain the ability to “drop down” and tweak a single pixel.\n\n\n\nThe SVG Advantage\nWhile TikZ is the gold standard for LaTeX-based PDF generation, it belongs to a “print-first” era. Tesserax leverages SVG (Scalable Vector Graphics) as its native format, offering a portability that TikZ cannot match without significant friction.\n\nNative Web Rendering: Tesserax figures are native SVGs. They render instantly in any browser, remain crisp at any zoom level, and can be embedded directly into HTML or Markdown (via Quarto) without conversion.\nWYSIWYG Portability: Converting TikZ to SVG for blog posts or online journals often results in broken fonts or misaligned elements. Because Tesserax starts with SVG, what you see in your development notebook is exactly what appears in your final PDF and your website.\nAccessibility & Interaction: Unlike static PDFs, Tesserax SVGs can include metadata and ARIA labels for screen readers. Since they are part of the DOM, they can also be styled with CSS or even animated for interactive educational content.\nPerfect Print: SVG is fully convertible to high-quality, vector-perfect PDF, meeting the highest standards for academic journals and book publishing."
  },
  {
    "objectID": "index.html#contribution",
    "href": "index.html#contribution",
    "title": "Tesserax: A Lightweight SVG Rendering Library",
    "section": "Contribution",
    "text": "Contribution\nTesserax is free as in both free beer and free speech. License is MIT.\nContributions are always welcomed! Fork, clone, and submit a pull request."
  },
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "Tesserax",
    "section": "",
    "text": "This guide will walk you through building a scene from scratch, demonstrating how Tesserax handles shapes, positioning, and composition."
  },
  {
    "objectID": "core.html#the-canvas-and-the-first-shape",
    "href": "core.html#the-canvas-and-the-first-shape",
    "title": "Tesserax",
    "section": "The Canvas and the First Shape",
    "text": "The Canvas and the First Shape\nEvery drawing starts with a Canvas. In Tesserax, the Canvas acts as the root container and provides a context manager to automatically add shapes created within its block.\nWe will start by creating a simple 100x50 rectangle.\n\n\nCode\nfrom tesserax import Canvas, Rect\n\n# Initialize the canvas\nwith Canvas() as canvas:\n    # Adding our first shape\n    # Primitives support standard SVG attributes like fill\n    Rect(100, 50, fill=\"lightblue\")\n\n# fit() adjusts the viewport to the content\n# display() renders it directly in the documentation\ncanvas.fit(padding=10).display()"
  },
  {
    "objectID": "core.html#drawing-text",
    "href": "core.html#drawing-text",
    "title": "Tesserax",
    "section": "Drawing Text",
    "text": "Drawing Text\nText behaves exactly like any other shape in Tesserax.\n\n\nCode\nfrom tesserax import Canvas, Text\n\nwith Canvas() as canvas:\n    Rect(150, 40, fill=\"lightblue\")\n    Text(\"Hello World\", size=24, font=\"serif\").translated(0, 22)\n\ncanvas.align(\"horizontal\").fit(10).display()"
  },
  {
    "objectID": "core.html#adding-and-transforming-shapes",
    "href": "core.html#adding-and-transforming-shapes",
    "title": "Tesserax",
    "section": "Adding and Transforming Shapes",
    "text": "Adding and Transforming Shapes\nWhile you can add shapes and manually set their coordinates, Tesserax provides a fluent API for transformations. Here, we add a Circle and use translated() to move it into position.\n\n\nCode\nfrom tesserax import Canvas, Rect, Circle\n\nwith Canvas() as canvas:\n    Rect(100, 50, fill=\"lightblue\")\n\n    # Adding a second shape and moving it manually\n    # Circle is defined by its radius\n    Circle(30, fill=\"salmon\").translated(150, 25)\n\ncanvas.fit(padding=10).display()"
  },
  {
    "objectID": "core.html#grouping-and-aligning-shapes",
    "href": "core.html#grouping-and-aligning-shapes",
    "title": "Tesserax",
    "section": "Grouping and Aligning Shapes",
    "text": "Grouping and Aligning Shapes\nThe Group class acts a container that has control over its children positions, so you can align and layout shapes easily with a procedural API.\n\n\nCode\nfrom tesserax import Canvas, Rect, Circle, Square, Group\n\nwith Canvas() as canvas:\n    with Group() as g:\n        Rect(100, 50, fill=\"lightblue\")\n        Circle(30, fill=\"salmon\")\n        Square(40, fill=\"pink\")\n\n    g.align(\"vertical\", \"center\").distribute(\"horizontal\", gap=10)\n\ncanvas.fit(padding=10).display()"
  },
  {
    "objectID": "core.html#simplifying-with-layouts",
    "href": "core.html#simplifying-with-layouts",
    "title": "Tesserax",
    "section": "Simplifying with Layouts",
    "text": "Simplifying with Layouts\nManually calculating offsets or calling procedural alignment becomes tedious in complex diagrams. Layouts automate this positioning. The Row layout arranges its children horizontally with an optional gap. The Column does so vertically.\n\n\nCode\nfrom tesserax import Canvas, Rect, Circle\nfrom tesserax.layout import Row\n\nwith Canvas() as canvas:\n    # Row is also a context manager\n    with Row(gap=10):\n        Rect(100, 50, fill=\"lightblue\")\n        Circle(30, fill=\"salmon\")\n        Square(40, fill=\"pink\")\n\ncanvas.fit(padding=10).display()"
  },
  {
    "objectID": "core.html#composing-transforms-and-groups",
    "href": "core.html#composing-transforms-and-groups",
    "title": "Tesserax",
    "section": "Composing Transforms and Groups",
    "text": "Composing Transforms and Groups\nBecause Layouts are themselves a type of Group, you can apply transformations to the entire layout at once. In this step, we will:\n\nCreate a Row layout.\nRotate that entire row by 45 degrees.\nAdd a new shape outside of that row.\nWrap everything in another Group to demonstrate hierarchical composition.\n\n\n\nCode\nfrom tesserax import Canvas, Rect, Circle, Group\nfrom tesserax.layout import Row\n\nwith Canvas() as canvas:\n    # Create and rotate a layout\n    with Row(gap=20).rotated(45):\n        Rect(100, 50, fill=\"lightblue\")\n        Circle(30, fill=\"salmon\")\n\n    # Add another shape to the scene\n    Rect(40, 40, fill=\"lightgreen\").translated(100, -50)\n\n    # All shapes here are already part of the Canvas group.\n\ncanvas.fit(padding=10).display()\n\n\n\n\n\n\n\n\n\nBy nesting Layouts and Groups, you can build extremely complex diagrams without ever having to manually compute a single SVG coordinate string."
  },
  {
    "objectID": "core.html#bridging-contexts-with-anchors",
    "href": "core.html#bridging-contexts-with-anchors",
    "title": "Tesserax",
    "section": "Bridging Contexts with Anchors",
    "text": "Bridging Contexts with Anchors\nOne of the most powerful features of Tesserax is the Anchor System. When you place a shape inside a Layout or a Group, its local coordinates change to reflect its position within that container. However, Tesserax allows you to retrieve the “global” position of a shape’s anchors, making it trivial to connect objects across different coordinate systems.\nIn this example, we will connect the Circle (which is inside a rotated Row) to the Rect (which is outside) using an Arrow, and the two shapes inside the row.\n\n\nCode\nfrom tesserax import Canvas, Rect, Circle, Arrow\nfrom tesserax.layout import Row\n\nwith Canvas() as canvas:\n    # 1. Create a Row and rotate it\n    with Row(gap=40) as row:\n        r1 = Rect(80, 40, fill=\"aliceblue\")\n        c1 = Circle(30, fill=\"mistyrose\")\n\n    row.rotated(30).translated(50, 50)\n\n    # 2. Create a target rectangle outside the layout\n    target = Rect(60, 60, fill=\"honeydew\").translated(250, 0)\n\n    # 3. Connect them!\n    # We use .anchor() to get semantic points.\n    # Even though c1 is inside a rotated row, c1.anchor(\"right\")\n    # returns the correct global coordinate for the arrow.\n    Arrow(\n        c1.anchor(\"top\").dy(-5),\n        target.anchor(\"left\").dx(-5),\n        stroke=\"grey\",\n        width=2,\n    )\n\n    Arrow(\n        r1.anchor(\"right\").dx(5),\n        c1.anchor(\"left\").dx(-5),\n        stroke=\"grey\",\n        width=2,\n    )\n\ncanvas.fit(padding=10).display()\n\n\n\n\n\n\n\n\n\n\nHow Coordinate Mapping Works\nWhen you call shape.anchor(name), Tesserax performs the following behind the scenes:\n\nLocal Geometry: It identifies the point on the shape (e.g., the rightmost edge of the Circle).\nTransformation Path: It traverses up the hierarchy (from the Circle to the Row, then to the Canvas), applying every rotation, scale, and translation encountered along the way.\nGlobal Result: It returns a Point that represents exactly where that anchor sits on the final SVG canvas.\n\nThis means you never have to manually calculate sin() or cos() to find where a rotated object’s edge is located—you just ask for the anchor.\nFor explicit anchoring, you can use Shape.resolve(p: Point) to map a point in local space to the global space, this way you can, e.g., get the point at 2/3rds of the way inside a rectangle and map it to global space."
  },
  {
    "objectID": "core.html#drawing-paths-and-lines",
    "href": "core.html#drawing-paths-and-lines",
    "title": "Tesserax",
    "section": "Drawing Paths and Lines",
    "text": "Drawing Paths and Lines\nWhile shapes like Rect and Circle cover many use cases, sometimes you need to draw arbitrary lines, custom shapes, or connectors. Tesserax offers two ways to do this: the low-level Path for precise control and the high-level Polyline for rapid sequences.\n\nThe Low-Level Path Object\nThe Path class roughly corresponds to the SVG &lt;path&gt; element. It operates like a pen: you move it to a location, then draw lines or curves to subsequent points.\nThis is ideal for creating custom glyphs or specific geometric curves.\n\n\nCode\nfrom tesserax import Canvas, Path\n\nwith Canvas() as canvas:\n    # 1. A simple custom shape (a triangle)\n    p = Path()\n    p.move_to(0, 0).line_to(50, 50).line_to(0, 50).close()\n    p.translated(20, 20)\n\n    # 2. A curved path using Bezier curves\n    curve = Path()\n    curve.move_to(100, 20)\n    # Cubic Bezier: 2 control points, 1 end point\n    curve.cubic_to(\n        150, 20,   # Control Point 1\n        150, 80,   # Control Point 2\n        200, 80    # End Point\n    )\n\n    # Quadratic Bezier: 1 control point, 1 end point\n    curve.quadratic_to(\n        250, 80,   # Control Point\n        300, 20    # End Point\n    )\n\ncanvas.fit(padding=10).display()\n\n\n\n\n\n\n\n\n\n\n\nThe High-Level Polyline\nFor many diagrams, you simply want to connect a sequence of points. The Polyline shape automates this.\nIts most powerful feature is the smoothness parameter. Instead of manually calculating Bezier control points to round a corner, you can simply tell Polyline to blend the corners for you.\n\nsmoothness=0: Sharp corners (standard polygon).\nsmoothness=0.2: Subtle rounded corners (like a modern UI box).\nsmoothness=1: Maximum rounding (spline-like).\n\n\n\nCode\nfrom tesserax import Canvas, Polyline, Point\n\n# Helper to generate a zigzag pattern\npoints = [\n    Point(0, 50), Point(50, 0), Point(100, 50),\n    Point(150, 0), Point(200, 50)\n]\n\nwith Canvas() as canvas:\n    # 1. Sharp Polyline (Default)\n    Polyline(points, smoothness=0).translated(0, 0)\n\n    # 2. Slightly Rounded (30% smoothing)\n    # Note how it preserves most of the straight line but rounds the tip.\n    Polyline(points, smoothness=0.3, stroke=\"blue\").translated(0, 60)\n\n    # 3. Fully Smooth (100% smoothing)\n    # This creates a flowing wave-like appearance, and closed.\n    Polyline(points, smoothness=1.0, stroke=\"red\", closed=True).translated(0, 120)\n\ncanvas.fit(10).display()\n\n\n\n\n\n\n\n\n\nThis makes Polyline an excellent tool for drawing graph edges, wiring diagrams, or “hand-drawn” style annotations where sharp vertices look unnatural."
  },
  {
    "objectID": "gallery.html",
    "href": "gallery.html",
    "title": "Gallery",
    "section": "",
    "text": "The following examples are a bit more involved and showcase the kind of drawings that can be done with Tesserax in the academic domain."
  },
  {
    "objectID": "gallery.html#sorting",
    "href": "gallery.html#sorting",
    "title": "Gallery",
    "section": "Sorting",
    "text": "Sorting\n\n\nCode\nfrom tesserax import Canvas, Square, Arrow, Group, Shape\nfrom tesserax.layout import Row\n\ndef create_pointer(target_shape: Shape, label_offset=40):\n    \"\"\"Helper to create a pointer arrow below a shape.\"\"\"\n    # We use the bottom anchor of the target shape\n    base = target_shape.anchor(\"bottom\")\n    # Start the arrow lower down (dy) and point up to the shape\n    tail = base.dy(label_offset)\n    head = base.dy(5) # Stop 5px short of the shape\n    return Arrow(tail, head)\n\nwith Canvas() as canvas:\n    elements: list[Shape] = []\n\n    # 1. The Array (Memory Strip)\n    # We use a Row layout to pack squares automatically\n    with Row(gap=0) as array:\n        for i in range(8):\n            # Highlight the pivot (last element) with a different style\n            is_pivot = (i == 7)\n            s = Square(\n                size=40,\n                stroke=\"red\" if is_pivot else \"black\",\n                fill=\"#ffebeb\" if is_pivot else \"white\"\n            )\n            elements.append(s)\n\n    # 2. The Pointers (i and j)\n    # We access the specific elements after the layout has settled\n    ptr_i = create_pointer(elements[2]) # Pointing to index 2\n    ptr_j = create_pointer(elements[5]) # Pointing to index 5\n\n    # 3. Pivot Label (Curved arrow from top)\n    pivot_shape = elements[-1]\n    pivot_top = pivot_shape.anchor(\"top\")\n\n    # Create a visual indicator for the pivot\n    pivot_arrow = Arrow(\n        pivot_top.d(20, -30), # Top-right offset\n        pivot_top.dy(-5)\n    )\n\ncanvas.fit(padding=20).display()"
  },
  {
    "objectID": "gallery.html#automaton",
    "href": "gallery.html#automaton",
    "title": "Gallery",
    "section": "Automaton",
    "text": "Automaton\nThis example uses a force layout to draw a simple graph that represents an automaton.\n\n\nCode\nimport math\nfrom tesserax import Canvas, Circle, Arrow\nfrom tesserax.layout import HierarchicalLayout\nfrom tesserax.core import Point\n\ndef get_boundary_point(center: Point, target: Point, radius: float) -&gt; Point:\n    \"\"\"Calculates a point on the circle's boundary facing the target.\"\"\"\n    dx = target.x - center.x\n    dy = target.y - center.y\n    dist = math.sqrt(dx*dx + dy*dy)\n    if dist == 0: return center\n\n    # Normalize and scale by radius\n    return Point(\n        center.x + (dx / dist) * radius,\n        center.y + (dy / dist) * radius\n    )\n\nwith Canvas() as canvas:\n    states: list[Shape] = []\n    radius = 20\n\n    # 1. Define the Graph Structure\n    with HierarchicalLayout(orientation=\"horizontal\") as graph:\n        # Create 5 states\n        for i in range(4):\n            states.append(Circle(r=radius))\n\n        # Connect them (Topology)\n        # q0 -&gt; q1 -&gt; q2\n        graph.connect(states[0], states[1])\n        graph.connect(states[0], states[2])\n        # q2 -&gt; q0 (cycle)\n        graph.connect(states[2], states[0])\n        # q2 -&gt; q3 -&gt; q4\n        graph.connect(states[2], states[3])\n        # Set the root\n        graph.root(states[0])\n\n    # 2. Draw Transitions (Visuals)\n    # We define edges manually to ensure directionality (ForceLayout is undirected)\n    transitions = [(0, 1), (1, 2), (2, 0), (2, 3)]\n\n    for i, j in transitions:\n        src = states[i].anchor(\"center\")\n        dst = states[j].anchor(\"center\")\n\n        # Calculate points on the boundary of the circles\n        p1 = get_boundary_point(src, dst, radius)\n        p2 = get_boundary_point(dst, src, radius)\n        Arrow(p1, p2)\n\n    # 3. Add a \"Start\" arrow pointing to q0\n    start_node = states[0].anchor(\"center\")\n    start_entry = get_boundary_point(start_node, start_node.dx(-100), radius)\n    Arrow(start_entry.dx(-40), start_entry)\n\ncanvas.fit(padding=10).display()"
  },
  {
    "objectID": "gallery.html#stack",
    "href": "gallery.html#stack",
    "title": "Gallery",
    "section": "Stack",
    "text": "Stack\nA simple illustration of a call stack.\n\n\nCode\n# examples/stack.py\nfrom tesserax import Canvas, Rect, Arrow, Group\nfrom tesserax.layout import Column\n\nwith Canvas() as canvas:\n    with Column(align=\"middle\", gap=2) as stack:\n        # Stack frames\n        for i in range(4):\n            # Top frame is active (different color)\n            stroke = \"blue\" if i == 0 else \"black\"\n            Rect(100, 30, stroke=stroke)\n\n    # Add a \"Stack Pointer\"\n    top_frame = stack.shapes[0]\n    sp_arrow = Arrow(\n        top_frame.anchor(\"left\").dx(-40),\n        top_frame.anchor(\"left\").dx(-5)\n    )\n\ncanvas.fit(padding=20).display()"
  },
  {
    "objectID": "gallery.html#neural-networks",
    "href": "gallery.html#neural-networks",
    "title": "Gallery",
    "section": "Neural Networks",
    "text": "Neural Networks\nThe following is a more complicated example showing how to visualize typical neural network operations like a convolution.\n\n\nCode\nfrom tesserax import Canvas, Square, Text, Arrow, Group, Shape\nfrom tesserax.layout import Grid, Row\n\n\ndef create_matrix(rows, cols, text, data=None, highlight_region=None, cell_size=40):\n    \"\"\"\n    Creates a grid of squares with optional text and highlighting.\n    \"\"\"\n    with Grid(cols=cols, gap=2) as grid:\n        for r in range(rows):\n            for c in range(cols):\n                val = data[r][c] if data else 0\n\n                # Determine styling based on the highlighted region\n                is_active = False\n                if highlight_region:\n                    r_start, c_start, r_end, c_end = highlight_region\n                    if r_start &lt;= r &lt;= r_end and c_start &lt;= c &lt;= c_end:\n                        is_active = True\n\n                # Visuals\n                color = \"#e3f2fd\" if is_active else \"white\"\n                stroke = \"#1565c0\" if is_active else \"black\"\n\n                # A Group holding the box and the number\n                with Group() as cell:\n                    box = Square(cell_size, fill=color, stroke=stroke)\n                    label = Text(str(val), size=14, font=\"monospace\")\n\n                cell.align()\n\n    t = Text(text, size=16, anchor=\"middle\")\n    t.align_to(grid, anchor=\"bottom\", other_anchor=\"top\").translated(0, -10)\n\n    # Return the group with these two elements\n    return grid + t\n\n\nwith Canvas() as canvas:\n    # Data Setup (Dummy Values)\n    input_data = [[1 if i == j else 0 for j in range(5)] for i in range(5)]\n    kernel_data = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]\n    output_data = [[2, 1, 2], [1, 3, 1], [2, 1, 2]]\n\n    # We put three matrices in a row with the corresponding texts in between\n    with Row(gap=20):\n        input_grid = create_matrix(\n            5, 5, \"Input (5x5)\", input_data, highlight_region=(0, 0, 2, 2)\n        )\n        math_op = Text(\"∗\", size=30)\n        kernel_grid = create_matrix(\n            3, 3, \"Kernel (3x3)\", kernel_data, highlight_region=(0, 0, 2, 2)\n        )\n        math_eq = Text(\"=\", size=30)\n        output_grid = create_matrix(\n            3, 3, \"Result (3x3)\", output_data, highlight_region=(0, 0, 0, 0)\n        )\n\ncanvas.fit(padding=40).display()"
  }
]