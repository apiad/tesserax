[
  {
    "objectID": "layout.html",
    "href": "layout.html",
    "title": "Layouts & Composition",
    "section": "",
    "text": "While you can position every shape manually using .translated(x, y), Tesserax shines when you let it handle the geometry for you. The layout system is built on a hierarchy of abstractions, starting from simple groups and moving up to force-directed graph algorithms."
  },
  {
    "objectID": "layout.html#grouping-objects",
    "href": "layout.html#grouping-objects",
    "title": "Layouts & Composition",
    "section": "Grouping Objects",
    "text": "Grouping Objects\nThe Group class is the fundamental unit of composition. It treats a collection of shapes as a single object, allowing you to transform them together.\n\nThe Context Manager Pattern\nThe most idiomatic way to create a group is with the with statement.\n\n\nCode\nfrom tesserax import Canvas, Group, Rect, Circle, Text\nfrom tesserax.color import Colors\n\nwith Canvas() as c:\n    # A group acts as a local container\n    with Group() as g:\n        Rect(100, 100, fill=Colors.LightBlue)\n        Text(\"Group 1\")\n\n    # You can transform the entire group at once\n    g.translated(50, 50)\n\n    with Group() as g2:\n        Circle(30, fill=Colors.Salmon)\n\n    g2.translated(150, 50)\n\nc.fit(10).display()\n\n\n\n\n\n\n\n\n\n\n\nManual Layouts: Align and Distribute\nBefore reaching for a full layout engine, you can often get what you need using the procedural API on Group.\n\n.align(axis, anchor): Aligns all children along an axis relative to the first child.\n.distribute(axis, gap, mode): Spaces children out evenly.\n\n\n\nCode\nfrom tesserax import Square\n\nwith Canvas() as c:\n    with Group() as g:\n        Square(20, fill=Colors.Red)\n        Square(30, fill=Colors.Green)\n        Square(40, fill=Colors.Blue)\n\n    # 1. Align centers vertically\n    g.align(\"vertical\", anchor=\"center\")\n\n    # 2. Distribute horizontally with 10px gap\n    g.distribute(\"horizontal\", gap=10)\n\n    g.translated(50, 50)\n\nc.fit(10).display()\n\n\n\n\n\n\n\n\n\n\n\nVisualizing Groups\nSometimes you want a group of shapes to also have a bounding frame. While you can build this easily with existing tools, Tesserax also provides a ready-made Container shape that automates this process.\n\n\nCode\nfrom tesserax import Container\n\nwith Canvas() as canvas:\n    with Container(padding=10, stroke=Colors.Gray, width=2) as c:\n        Rect(30, 20, fill=Colors.Red)\n        Circle(15, fill=Colors.Green)\n        Square(25, fill=Colors.Blue)\n\n    c.distribute(\"horizontal\", gap=10)\n\ncanvas.fit().display()"
  },
  {
    "objectID": "layout.html#standard-layouts",
    "href": "layout.html#standard-layouts",
    "title": "Layouts & Composition",
    "section": "Standard Layouts",
    "text": "Standard Layouts\nStandard layouts like Row and Column are specialized Groups that automatically apply alignment and distribution logic when they are closed.\n\nRow and Column\nThese layouts are perfect for linear arrangements. They can be nested arbitrarily.\n\n\nCode\nfrom tesserax.layout import RowLayout, ColumnLayout\n\nwith Canvas() as c:\n    # A Row automatically distributes horizontally\n    with RowLayout(gap=10, align=\"middle\") as row:\n        Rect(20, 40, fill=Colors.LightGray)\n        Circle(15, fill=Colors.MistyRose)\n        Rect(20, 20, fill=Colors.LightCoral)\n\n        # A Column automatically distributes vertically\n        # Notice we can nest layouts\n        with ColumnLayout(gap=10, align=\"middle\") as col:\n            Rect(40, 20, fill=Colors.PowderBlue)\n            Circle(15, fill=Colors.Thistle)\n\nc.fit(10).display()\n\n\n\n\n\n\n\n\n\n\n\nThe Grid Layout\nThe Grid layout provides a powerful 2D arrangement system. Unlike a simple HTML table, the Tesserax Grid allows for spanning and alignment control per cell.\n\n\nCode\nfrom tesserax.layout import GridLayout\n\nwith Canvas() as c:\n    # 2 columns, automatic rows\n    with GridLayout(cols=2, gap=10) as grid:\n        Rect(50, 50, fill=Colors.LightCyan)\n        Rect(50, 50, fill=Colors.LightCyan)\n\n        # This will wrap to the next row\n        Rect(110, 50, fill=Colors.LightYellow) # Span visually if wide\n\n        Rect(50, 50, fill=Colors.LightCyan)\n\nc.fit(10).display()"
  },
  {
    "objectID": "layout.html#complex-layouts",
    "href": "layout.html#complex-layouts",
    "title": "Layouts & Composition",
    "section": "Complex Layouts",
    "text": "Complex Layouts\nFor data structures where manual positioning is impossible (like graphs or trees), Tesserax provides algorithmic layouts.\n\nHierarchical Layout (Trees & DAGs)\nThe HierarchicalLayout is designed for directed acyclic graphs and trees. It automatically calculates levels and minimizes edge crossings.\n\n\nCode\nfrom tesserax.layout import HierarchicalLayout\nfrom tesserax import Arrow\n\nwith Canvas() as c:\n    with HierarchicalLayout(orientation=\"vertical\") as tree:\n        root = Circle(20, fill=Colors.Gold)\n        l = Circle(15, fill=Colors.LightBlue)\n        r = Circle(15, fill=Colors.LightBlue)\n        ll = Circle(10, fill=Colors.LightGreen)\n        lr = Circle(10, fill=Colors.LightGreen)\n\n        tree.root(root)\n        tree.connect(root, l)\n        tree.connect(root, r)\n        tree.connect(l, ll)\n        tree.connect(l, lr)\n\n    # Define connections (Layout will position nodes, you draw edges)\n    Arrow(root.anchor(\"bottom\"), l.anchor(\"top\"))\n    Arrow(root.anchor(\"bottom\"), r.anchor(\"top\"))\n    Arrow(l.anchor(\"bottom\"), ll.anchor(\"top\"))\n    Arrow(l.anchor(\"bottom\"), lr.anchor(\"top\"))\n\nc.fit(10).display()\n\n\n\n\n\n\n\n\n\n\n\nForce-Directed Layout\nThe ForceLayout uses a physics simulation (Fruchterman-Reingold) to position nodes. This is ideal for arbitrary network graphs where structure is emergent.\nThe layout requires you to define nodes and links (edges).\n\n\nCode\nfrom tesserax.layout import ForceLayout\nfrom tesserax import Line, Shape\n\nwith Canvas() as c:\n    nodes: list[Shape] = []\n\n    # 1. Initialize Layout\n    with ForceLayout() as layout:\n        # 2. Add Nodes (they are just shapes)\n        for i in range(5):\n            n = Circle(10, fill=Colors.Orange)\n            nodes.append(n)\n            layout.add(n)\n\n        # 3. Add Constraints (links)\n        layout.connect(nodes[0], nodes[1])\n        layout.connect(nodes[1], nodes[2])\n        layout.connect(nodes[2], nodes[0]) # Triangle\n        layout.connect(nodes[2], nodes[3])\n        layout.connect(nodes[3], nodes[4])\n\n    # 5. Draw Edges based on computed positions\n    # (We draw edges *after* compute so anchors are correct)\n    Line(nodes[0].anchor(\"center\"), nodes[1].anchor(\"center\"))\n    Line(nodes[1].anchor(\"center\"), nodes[2].anchor(\"center\"))\n    Line(nodes[2].anchor(\"center\"), nodes[0].anchor(\"center\"))\n    Line(nodes[2].anchor(\"center\"), nodes[3].anchor(\"center\"))\n    Line(nodes[3].anchor(\"center\"), nodes[4].anchor(\"center\"))\n\nc.fit(10).display()"
  },
  {
    "objectID": "gallery.html",
    "href": "gallery.html",
    "title": "Gallery",
    "section": "",
    "text": "The following examples are a bit more involved and showcase the kind of drawings that can be done with Tesserax in the academic domain."
  },
  {
    "objectID": "gallery.html#sorting",
    "href": "gallery.html#sorting",
    "title": "Gallery",
    "section": "Sorting",
    "text": "Sorting\n\n\nCode\nfrom tesserax import Canvas, Square, Arrow, Group, Shape\nfrom tesserax.layout import RowLayout\n\ndef create_pointer(target_shape: Shape, label_offset=40):\n    \"\"\"Helper to create a pointer arrow below a shape.\"\"\"\n    # We use the bottom anchor of the target shape\n    base = target_shape.anchor(\"bottom\")\n    # Start the arrow lower down (dy) and point up to the shape\n    tail = base.dy(label_offset)\n    head = base.dy(5) # Stop 5px short of the shape\n    return Arrow(tail, head)\n\nwith Canvas() as canvas:\n    elements: list[Shape] = []\n\n    # 1. The Array (Memory Strip)\n    # We use a Row layout to pack squares automatically\n    with RowLayout(gap=0) as array:\n        for i in range(8):\n            # Highlight the pivot (last element) with a different style\n            is_pivot = (i == 7)\n            s = Square(\n                size=40,\n                stroke=\"red\" if is_pivot else \"black\",\n                fill=\"#ffebeb\" if is_pivot else \"white\"\n            )\n            elements.append(s)\n\n    # 2. The Pointers (i and j)\n    # We access the specific elements after the layout has settled\n    ptr_i = create_pointer(elements[2]) # Pointing to index 2\n    ptr_j = create_pointer(elements[5]) # Pointing to index 5\n\n    # 3. Pivot Label (Curved arrow from top)\n    pivot_shape = elements[-1]\n    pivot_top = pivot_shape.anchor(\"top\")\n\n    # Create a visual indicator for the pivot\n    pivot_arrow = Arrow(\n        pivot_top.d(20, -30), # Top-right offset\n        pivot_top.dy(-5)\n    )\n\ncanvas.fit(padding=20).display()"
  },
  {
    "objectID": "gallery.html#automaton",
    "href": "gallery.html#automaton",
    "title": "Gallery",
    "section": "Automaton",
    "text": "Automaton\nThis example uses a force layout to draw a simple graph that represents an automaton.\n\n\nCode\nimport math\nfrom tesserax import Canvas, Circle, Arrow\nfrom tesserax.layout import HierarchicalLayout\nfrom tesserax.core import Point\n\ndef get_boundary_point(center: Point, target: Point, radius: float) -&gt; Point:\n    \"\"\"Calculates a point on the circle's boundary facing the target.\"\"\"\n    dx = target.x - center.x\n    dy = target.y - center.y\n    dist = math.sqrt(dx*dx + dy*dy)\n    if dist == 0: return center\n\n    # Normalize and scale by radius\n    return Point(\n        center.x + (dx / dist) * radius,\n        center.y + (dy / dist) * radius\n    )\n\nwith Canvas() as canvas:\n    states: list[Shape] = []\n    radius = 20\n\n    # 1. Define the Graph Structure\n    with HierarchicalLayout(orientation=\"horizontal\") as graph:\n        # Create 5 states\n        for i in range(4):\n            states.append(Circle(r=radius))\n\n        # Connect them (Topology)\n        # q0 -&gt; q1 -&gt; q2\n        graph.connect(states[0], states[1])\n        graph.connect(states[0], states[2])\n        # q2 -&gt; q0 (cycle)\n        graph.connect(states[2], states[0])\n        # q2 -&gt; q3 -&gt; q4\n        graph.connect(states[2], states[3])\n        # Set the root\n        graph.root(states[0])\n\n    # 2. Draw Transitions (Visuals)\n    # We define edges manually to ensure directionality (ForceLayout is undirected)\n    transitions = [(0, 1), (1, 2), (2, 0), (2, 3)]\n\n    for i, j in transitions:\n        src = states[i].anchor(\"center\")\n        dst = states[j].anchor(\"center\")\n\n        # Calculate points on the boundary of the circles\n        p1 = get_boundary_point(src, dst, radius)\n        p2 = get_boundary_point(dst, src, radius)\n        Arrow(p1, p2)\n\n    # 3. Add a \"Start\" arrow pointing to q0\n    start_node = states[0].anchor(\"center\")\n    start_entry = get_boundary_point(start_node, start_node.dx(-100), radius)\n    Arrow(start_entry.dx(-40), start_entry)\n\ncanvas.fit(padding=10).display()"
  },
  {
    "objectID": "gallery.html#stack",
    "href": "gallery.html#stack",
    "title": "Gallery",
    "section": "Stack",
    "text": "Stack\nA simple illustration of a call stack.\n\n\nCode\n# examples/stack.py\nfrom tesserax import Canvas, Rect, Arrow, Group\nfrom tesserax.layout import ColumnLayout\n\nwith Canvas() as canvas:\n    with ColumnLayout(align=\"middle\", gap=2) as stack:\n        # Stack frames\n        for i in range(4):\n            # Top frame is active (different color)\n            stroke = \"blue\" if i == 0 else \"black\"\n            Rect(100, 30, stroke=stroke)\n\n    # Add a \"Stack Pointer\"\n    top_frame = stack.shapes[0]\n    sp_arrow = Arrow(\n        top_frame.anchor(\"left\").dx(-40),\n        top_frame.anchor(\"left\").dx(-5)\n    )\n\ncanvas.fit(padding=20).display()"
  },
  {
    "objectID": "gallery.html#neural-networks",
    "href": "gallery.html#neural-networks",
    "title": "Gallery",
    "section": "Neural Networks",
    "text": "Neural Networks\nThe following is a more complicated example showing how to visualize typical neural network operations like a convolution.\n\n\nCode\nfrom tesserax import Canvas, Square, Text, Arrow, Group, Shape\nfrom tesserax.layout import GridLayout, RowLayout\n\n\ndef create_matrix(rows, cols, text, data=None, highlight_region=None, cell_size=40):\n    \"\"\"\n    Creates a grid of squares with optional text and highlighting.\n    \"\"\"\n    with GridLayout(cols=cols, gap=2) as grid:\n        for r in range(rows):\n            for c in range(cols):\n                val = data[r][c] if data else 0\n\n                # Determine styling based on the highlighted region\n                is_active = False\n                if highlight_region:\n                    r_start, c_start, r_end, c_end = highlight_region\n                    if r_start &lt;= r &lt;= r_end and c_start &lt;= c &lt;= c_end:\n                        is_active = True\n\n                # Visuals\n                color = \"#e3f2fd\" if is_active else \"white\"\n                stroke = \"#1565c0\" if is_active else \"black\"\n\n                # A Group holding the box and the number\n                with Group() as cell:\n                    box = Square(cell_size, fill=color, stroke=stroke)\n                    label = Text(str(val), size=14, font=\"monospace\")\n\n                cell.align()\n\n    t = Text(text, size=16, anchor=\"middle\")\n    t.align_to(grid, anchor=\"bottom\", other_anchor=\"top\").translated(0, -10)\n\n    # Return the group with these two elements\n    return grid + t\n\n\nwith Canvas() as canvas:\n    # Data Setup (Dummy Values)\n    input_data = [[1 if i == j else 0 for j in range(5)] for i in range(5)]\n    kernel_data = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]\n    output_data = [[2, 1, 2], [1, 3, 1], [2, 1, 2]]\n\n    # We put three matrices in a row with the corresponding texts in between\n    with RowLayout(gap=20):\n        input_grid = create_matrix(\n            5, 5, \"Input (5x5)\", input_data, highlight_region=(0, 0, 2, 2)\n        )\n        math_op = Text(\"∗\", size=30)\n        kernel_grid = create_matrix(\n            3, 3, \"Kernel (3x3)\", kernel_data, highlight_region=(0, 0, 2, 2)\n        )\n        math_eq = Text(\"=\", size=30)\n        output_grid = create_matrix(\n            3, 3, \"Result (3x3)\", output_data, highlight_region=(0, 0, 0, 0)\n        )\n\ncanvas.fit(padding=40).display()"
  },
  {
    "objectID": "gallery.html#the-physics-blob",
    "href": "gallery.html#the-physics-blob",
    "title": "Gallery",
    "section": "The Physics Blob",
    "text": "The Physics Blob\nThis example demonstrates how to create a custom Composite Shape. We build a ConvexHull component that wraps a set of physics bodies. By connecting the bodies with springs and wrapping them in a smooth hull, we create a soft-body “Jelly” simulation.\nFirst, we implement the geometry logic. This component takes a list of shapes, collects their vertices, and uses the Graham Scan algorithm to compute the convex hull.\n\n\nCode\nimport math\nfrom functools import reduce\nfrom tesserax import Group, Polyline, Point, Colors\n\nclass ConvexHull(Group):\n    def __init__(self, shapes=None, fill=Colors.Transparent, stroke=Colors.Black, **kwargs):\n        super().__init__(shapes)\n        # The visual representation of the hull\n        self.hull = Polyline([], closed=True, fill=fill, stroke=stroke, **kwargs)\n\n    def _graham_scan(self, points: list[Point]) -&gt; list[Point]:\n        \"\"\"Computes the Convex Hull of a set of points.\"\"\"\n        if len(points) &lt; 3: return points\n\n        # 1. Find the bottom-most point (and left-most if ties)\n        p0 = min(points, key=lambda p: (p.y, p.x))\n\n        # 2. Sort by polar angle with respect to p0\n        def polar_angle(p):\n            return math.atan2(p.y - p0.y, p.x - p0.x)\n\n        # Sort by angle, then distance\n        sorted_points = sorted(points, key=lambda p: (polar_angle(p), p.distance(p0)))\n\n        # 3. Build the hull\n        stack = []\n        for p in sorted_points:\n            while len(stack) &gt; 1:\n                # Cross product to check for left turn\n                a = stack[-2]\n                b = stack[-1]\n                c = p\n                cross = (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x)\n                if cross &lt;= 0: # Non-left turn\n                    stack.pop()\n                else:\n                    break\n            stack.append(p)\n\n        return stack\n\n    def _render(self) -&gt; str:\n        # 1. Collect all \"corners\" from child shapes\n        # For better blobs, we could sample points from circles, but bounds corners works for high N\n        cloud = []\n        for s in self.shapes:\n            b = s.bounds()\n            cloud.extend([\n                Point(b.x, b.y),\n                Point(b.x + b.width, b.y),\n                Point(b.x + b.width, b.y + b.height),\n                Point(b.x, b.y + b.height)\n            ])\n\n        # 2. Compute Hull\n        if cloud:\n            self.hull.points = self._graham_scan(cloud)\n\n        # 3. Render the Hull instead of the children\n        # (We assume the children are invisible physics particles)\n        return self.hull.render()\n\n\nNow we simulate the “Jelly.” We create a central particle connected to a ring of outer particles using springs.\n\n\nCode\nimport random\nfrom tesserax import Canvas, Circle, Rect\nfrom tesserax.physics import World, Body, Gravity, CircleCollider, Material\nfrom tesserax.physics.constraints import Spring\nfrom tesserax.animation import Scene\n\ncanvas = Canvas()\nworld = World()\n\n# Parameters\ncenter_x, center_y = 300, 100\nradius = 60\nnum_points = 30\n\n# 1. Create Particles\nparticles = []\n\n# Center particle\ncenter_shape = Circle(20).translated(center_x, center_y)\ncenter_body = world.add(\n    center_shape,\n    mass=1.0,\n    collider=CircleCollider(20),\n    material=Material(restitution=0.8),\n)\n\n# Ring particles\nfor i in range(num_points):\n    angle = (2 * math.pi * i) / num_points\n    px = center_x + math.cos(angle) * radius\n    py = center_y + math.sin(angle) * radius\n\n    # Tiny circle particles (invisible inside the blob)\n    s = Circle(10).translated(px, py)\n    b = world.add(\n        s, mass=0.5, collider=CircleCollider(10), material=Material(restitution=0.8)\n    )\n    particles.append(b)\n\n    # Connect to center (Spokes)\n    # Stiffness 0.5 makes it wobbly\n    world.constraint(Spring(center_body, b, length=radius, k=100))\n\n# Connect ring neighbors (Perimeter)\nfor i in range(num_points):\n    b1 = particles[i]\n    b2 = particles[(i + 1) % num_points]\n    dist = 2 * radius * math.sin(math.pi / num_points)\n    world.constraint(Spring(b1, b2, length=dist, k=100))\n\n# 2. Wrap in the Hull\n# smoothness=0.5 makes the polyline rounded (Catmull-Rom splines)\nblob_shapes = [p.shape for p in particles]\nblob = ConvexHull(\n    blob_shapes,\n    fill=Colors.Teal,\n    stroke=Colors.Black,\n    width=2,\n    smoothness=1,  # Essential for the \"organic\" look\n)\ncanvas.add(blob)\n\n# Add a floor\nfloor = Rect(600, 20, fill=Colors.Black).translated(300, 380)\nworld.add(floor, static=True, material=Material(restitution=0.8))\ncanvas.add(floor)\n\n# 3. Simulate\n# 5 seconds of dropping and bouncing\nworld.fields.append(Gravity())\nanim = world.simulate(duration=5.0)\n\n# Camera fitting\nscene = Scene(canvas)\nscene.canvas.fit(bounds=anim.bounds, padding=10)\nscene.play(anim, duration=10)\n\nscene.display()"
  },
  {
    "objectID": "posts/charting-blog-post.html",
    "href": "posts/charting-blog-post.html",
    "title": "Declarative Charting in Pure Python with Tesserax",
    "section": "",
    "text": "Have you ever felt caught in the no-man’s-land of Python visualization? On one side, you have powerful, full-featured libraries like Matplotlib or Seaborn. They are the heavyweights, capable of producing nearly any plot imaginable, but often at the cost of wrestling with verbose APIs and complex object models. On the other side, you have low-level graphics engines where you must manually draw every circle, line, and label. You get ultimate control, but the work to create a simple bar chart from scratch is immense.\nThis is the gap I’ve been living in. It’s the reason I originally created Tesserax, my zero-dependency, pure Python library for programmatic SVG graphics. I wanted a tool that provided low-level, geometric primitives but also included high-level components for common tasks.\nToday, I’m excited to introduce the next step in that vision: a brand-new, declarative charting module for Tesserax. My thesis is that we can have the best of both worlds. We can have a simple, expressive API for statistical graphics that is also fully integrated into a flexible, composable graphics engine.\nThe philosophy behind this new module is the Grammar of Graphics, the same elegant concept that powers libraries like R’s ggplot2 and Python’s Altair. Instead of telling the computer how to draw a chart, you simply declare how your data maps to visual properties. You say, “the ‘sales’ column maps to the y-axis, and the ‘city’ column maps to the x-axis,” and the library handles the rest.\nThe result? You can create beautiful, animated, and highly customizable charts with shockingly little code.\nTake a look at the animation we’re going to build throughout this post. It visualizes a changing dataset, smoothly handling bars that grow, new bars that enter, and old bars that exit the scene."
  },
  {
    "objectID": "posts/charting-blog-post.html#building-a-visualization-layer-by-layer",
    "href": "posts/charting-blog-post.html#building-a-visualization-layer-by-layer",
    "title": "Declarative Charting in Pure Python with Tesserax",
    "section": "Building a Visualization, Layer by Layer",
    "text": "Building a Visualization, Layer by Layer\nThe term “Grammar of Graphics” sounds more intimidating than it is. At its heart, it’s a simple but profound idea: a chart is a sentence, and your data provides the words. Instead of thinking imperatively (“draw a rectangle here with this height…”), we think declaratively (“let the value field of my data determine the height of the bars”).\nThis declarative approach is built on three pillars:\n\nData: The raw material. In Python, this is typically a list of dictionaries.\nMark: The geometric shape that represents a single data record. Think of this as the noun of your visual sentence (e.g., a point, a line, a bar).\nEncoding: This is the magic, the verb of the sentence. An encoding connects a data field to a visual property of the mark, like x position, y position, color, or size.\n\nLet’s build up a chart layer by layer to see this in practice. We’ll start with a simple dataset.\n\n\nCode\n# A richer dataset with a third dimension\nsales_data = [\n    {\"category\": \"A\", \"sales\": 45, \"region\": \"North\"},\n    {\"category\": \"B\", \"sales\": 90, \"region\": \"South\"},\n    {\"category\": \"C\", \"sales\": 65, \"region\": \"North\"},\n    {\"category\": \"D\", \"sales\": 25, \"region\": \"West\"},\n]\n\n\nOur first chart was a bare-bones bar chart. It’s a good start, but real-world data is often multidimensional. What if we want to visualize the region as well? We can simply map it to the color channel.\nAnd while we’re at it, a chart without axes is just abstract art. Let’s add them by chaining .axis() calls.\n\n\nCode\nfrom tesserax import Canvas, Chart\n\n# ... sales_data from above ...\n\nwith Canvas(width=400, height=250) as canvas:\n    Chart(sales_data) \\\n        .bar() \\\n        .encode(\n            x=\"category\",\n            y=\"sales\",\n            color=\"region\"  # Map the 'region' field to color\n        ) \\\n        .axis(\"x\", title=\"Product Category\") \\\n        .axis(\"y\", title=\"Sales Volume\", grid=True)\n\ncanvas.fit(20).display()\n\n\n\n\n\n\n\n\n\nJust by adding color=\"region\" to our encoding, Tesserax automatically assigns a distinct color from its palette to each unique value in the region field and handles the underlying scales. The .axis() calls give our visualization context, adding titles and a faint gridline on the y-axis.\nNow for the real magic of this grammatical approach. What if we decide a bar chart isn’t the right visualization? Do we have to start over?\nNo. We just change the “noun” of our sentence. Let’s swap .bar() for .point().\n\n\nCode\nfrom tesserax import Canvas, Chart\n\n# ... sales_data from above ...\n\nwith Canvas(width=400, height=250) as canvas:\n    Chart(sales_data) \\\n        .point(size=10) \\\n        .encode(\n            x=\"category\",\n            y=\"sales\",\n            color=\"region\"\n        ) \\\n        .axis(\"x\", title=\"Product Category\") \\\n        .axis(\"y\", title=\"Sales Volume\", grid=True)\n\ncanvas.fit(20).display()\n\n\n\n\n\n\n\n\n\nAnd just like that, we have a dot plot. All our other declarative mappings—x-position, y-position, color, and axes—are automatically reapplied to the new mark type. This is the flexibility I was striving for: the ability to rapidly iterate on the design of a visualization by simply swapping out its fundamental components."
  },
  {
    "objectID": "posts/charting-blog-post.html#how-it-works",
    "href": "posts/charting-blog-post.html#how-it-works",
    "title": "Declarative Charting in Pure Python with Tesserax",
    "section": "How It Works",
    "text": "How It Works\nNow that we’ve seen what the charting module can do, let’s pull back the curtain and talk about how it does it. When I designed this system, my primary goal wasn’t just to create a nice API, but to build an engine that was as modular and extensible as the charts it produces. The entire system is a collaboration between a few specialist components, and understanding them is the key to unlocking the library’s full potential.\nAt the center of it all is the Chart component. Think of it as the project manager or the conductor of an orchestra. It doesn’t actually draw anything itself. Its job is to look at the data you provided, examine the encodings you declared, and delegate the hard work to two key groups of specialists: Scales and Marks.\n\nScales\nA scale’s job is to translate from the “data world” to the “pixel world.” It answers questions like, “If my sales can range from 0 to 100, and my chart is 300 pixels tall, where exactly should a value of 45 be located?”\nTesserax uses a few types of scales, each for a different kind of data:\n\nLinearScale: This is your standard ruler. It maps a continuous numerical domain (e.g., values from 0 to 1000) onto a continuous pixel range (e.g., 0px to 500px).\nBandScale: This is for categorical data. It takes a domain like ['A', 'B', 'C'] and divides the available space into evenly spaced “bands,” calculating the correct position and width for each one, including padding.\nColorScale: This scale maps a data domain (e.g., ['North', 'South', 'West']) to a palette of distinct, visually pleasing colors.\n\nThe beauty of this design is its extensibility. The Chart component only interacts with a generic Scale base class. This means we can easily introduce new kinds of scales. Imagine creating a LogScale for data that spans several orders of magnitude. As long as it conforms to the basic scale “protocol” (implementing a map() method), the Chart component can use it to build a logarithmic plot without any other changes to the system.\n\n\nMarks\nIf scales are the translators, marks are the artists. A mark’s job is to take the pixel coordinates provided by the scales for a single row of data and produce a concrete geometric Shape.\n\nThe BarMark looks at the x and y values from the scales and draws a Rect.\nThe PointMark does the same but draws a Circle.\n\nThis is another area designed for extension. Do you want to create a line chart? You could create a LineMark. This new mark would receive the coordinates for all the data points at once and produce a single Polyline shape. Once that LineMark is defined, a user could simply call .line() on their chart, and all the existing machinery for scales, axes, and encodings would work instantly. You could imagine creating AreaMark for area charts, or even a custom CandlestickMark for financial data.\n\n\nChannels\nFinally, the X, Y, and Color objects you’ve seen are simple channels. They are simple data structures that bundle a data field with its configuration (like axis or legend information). This provides a clean way to pass structured information from the user’s .encode() call down to the Chart orchestrator. This, too, is extensible. One could design a Size channel that maps a data field to the size of the marks, and the PointMark could be taught to use it.\nThis modular, protocol-oriented design is the engine’s secret weapon. By ensuring each component has a single, well-defined responsibility, we create a system that is not only powerful out of the box, but one that can be easily and cleanly extended in any direction."
  },
  {
    "objectID": "posts/charting-blog-post.html#the-killer-feature",
    "href": "posts/charting-blog-post.html#the-killer-feature",
    "title": "Declarative Charting in Pure Python with Tesserax",
    "section": "The Killer Feature",
    "text": "The Killer Feature\nStatic charts are good, but animated charts are storytellers. They can reveal trends, highlight changes, and provide a much deeper intuition for how a system evolves. The problem is that creating these transitions manually is often a nightmare of state management and tedious interpolation.\nThis is where the declarative nature of the charting module truly shines. To animate a chart, you don’t manually calculate new positions or sizes. You just give it the new dataset, and Tesserax handles the rest.\nThis is all built on a classic data visualization pattern called Enter-Update-Exit:\n\nEnter: When a new item appears in your data (like “Houston” in our example), the framework creates a new shape for it and animates it into the scene (e.g., fading in and growing from the baseline).\nUpdate: For data items that exist in both the old and new datasets (like “Chicago”), the framework smoothly animates their corresponding shapes from their old properties to their new ones.\nExit: When a data item is removed from the data (like “New York”), its corresponding shape is gracefully animated out of the scene before being removed.\n\nTo make this work, Tesserax needs to know which shape corresponds to which piece of data. It determines this “data identity” by checking, in order: 1) for a special id or _id field in the data row, 2) the value of the field mapped to the x channel, or 3) the row’s index in the list.\nHere is the code that generated the animation you saw at the beginning of this post. Notice that we simply define the chart with the first dataset, and then tell the animation Scene to play the transition to the second dataset.\n\n\nCode\nfrom tesserax import Canvas\nfrom tesserax.animation import Scene\nfrom tesserax.chart import Chart\n\n# The initial state of our data\ndata_v1 = [\n    {\"city\": \"New York\", \"sales\": 40, \"region\": \"East\"},\n    {\"city\": \"Chicago\", \"sales\": 60, \"region\": \"Central\"},\n    {\"city\": \"Los Angeles\", \"sales\": 50, \"region\": \"West\"},\n]\n\n# The state after the data has changed\ndata_v2 = [\n    {\"city\": \"Chicago\", \"sales\": 90, \"region\": \"Central\"}, # Update\n    {\"city\": \"Los Angeles\", \"sales\": 50, \"region\": \"West\"}, # Unchanged\n    {\"city\": \"Houston\", \"sales\": 75, \"region\": \"South\"},     # Enter\n    # New York was removed (Exit)\n]\n\nwith Canvas() as canvas:\n    chart = Chart(data_v1, width=400, height=220) \\\n        .bar(padding=0.2) \\\n        .encode(x=\"city\", y=\"sales\", color=\"region\") \\\n        .axis(\"x\", title=\"City\") \\\n        .axis(\"y\", title=\"Sales (in thousands)\", grid=True)\n\nscene = Scene(canvas.fit(20))\n\n# This is the key! Generate the animation by providing the new data.\nanimation = chart.animate.data(data_v2).pad(0.5, 0.5)\n\nscene.play(animation, duration=2)\nscene.display()\n\n\n\n\n\nThe most important part of this is that chart.animate.data(data_v2) does not introduce a new, separate animation system. It’s a factory that generates a standard Tesserax Animation object. Under the hood, it’s just a Sequence of Parallel animations—the same building blocks used for all other animations in the library.\nThis means a chart animation is a first-class citizen in the Tesserax ecosystem. You can loop it, reverse it, combine it with other animations, or apply custom easing functions. For example, you could have the chart animate while the title scrambles into view, and run the whole sequence in a loop, because it’s all built on the same composable animation primitives. This is the architectural payoff: building high-level features on a solid, low-level foundation."
  },
  {
    "objectID": "posts/charting-blog-post.html#closing-the-loop",
    "href": "posts/charting-blog-post.html#closing-the-loop",
    "title": "Declarative Charting in Pure Python with Tesserax",
    "section": "Closing the Loop",
    "text": "Closing the Loop\nPerhaps the most powerful, if subtle, feature of this entire system is that a Chart is not a special, siloed object. It’s just another Tesserax component, like a Rect, a Circle, or a Group. This means you can rotate it, scale it, or arrange it in complex layouts right alongside any other graphical element. This composability was the final piece of the puzzle I set out to solve.\nWith a core graphics engine, a physics and animation system, and now a declarative charting module, the Tesserax library finally feels feature-complete. While I may add a new Mark or Scale here and there as needs arise, the major architectural work is done. The library has reached a stable point, closing the gap I identified at the start.\nMy goal was never to build a library for its own sake, but to create a tool for a purpose: to write better computer science explainers with beautiful, clear, and often animated illustrations. Now, I can finally get back to that.\nI encourage you to take Tesserax for a spin. The library is fully open-source and available on PyPI.\nTry out the charting module, build something cool, and let me know what you think by opening an issue or discussion on the GitHub repository, or leave me a comment right here.\nI can’t wait to see what you create."
  },
  {
    "objectID": "physics.html",
    "href": "physics.html",
    "title": "Physics-based Animations",
    "section": "",
    "text": "Tesserax includes a built-in, deterministic, baked physics engine. Unlike real-time game engines that calculate physics during the render loop, Tesserax calculates the entire simulation upfront and “bakes” it into standard KeyframeAnimation tracks.\nThis architecture offers two major advantages:"
  },
  {
    "objectID": "physics.html#the-basic",
    "href": "physics.html#the-basic",
    "title": "Physics-based Animations",
    "section": "The Basic",
    "text": "The Basic\nA high-level overview of the workflow is as follows:\n\nCreate a World.\nAdd Shape objects to the world (creates Body wrappers).\nAdd Fields (like Gravity) and global constraints.\nCall world.simulate(duration) to generate an Animation.\nPlay the animation in your Scene.\n\nHere is a complete example of a ball falling under gravity and bouncing on a static floor. First we will create the scene.\n\n\nCode\nfrom tesserax import Canvas, Circle, Rect\n\n# 1. Setup the Scene\nwith Canvas() as canvas:\n    floor = Rect(100, 20, fill=\"#333\").translated(0, 200)\n    ball = Circle(20, fill=\"#ff0055\").translated(00, 0)\n\n\nNext, we define the physical world. This involves wrapping the existing shapes that will undergo physical simulation as Bodys and place them in a World. Once set up, we bake the physics animation with world.simulate(...).\n\n\nCode\nfrom tesserax.physics import World, Gravity, Material, CircleCollider\n\nworld = World()\nworld.fields.append(Gravity())  # Downward acceleration (pixels/s^2)\nworld.add(floor, static=True, material=Material(restitution=0.8))\nworld.add(\n    ball,\n    material=Material(restitution=0.8, friction=0.5),\n    collider=CircleCollider(ball.r),\n)\n\nsimulation = world.simulate(duration=5.0)\n\n\nFinally, we run the animation as normal. Notice we can simulate at some fixed framerate and render at a completely different rate. The property simulation.bounds has a precomputed approximate bounding box of the entire simulation so we can fit to it.\n\n\nCode\nfrom tesserax.animation import Scene\n\ncanvas.fit(10, bounds=simulation.bounds)\nscene = Scene(canvas)\nscene.play(simulation, duration=5.0)\nscene.display()"
  },
  {
    "objectID": "physics.html#constraints",
    "href": "physics.html#constraints",
    "title": "Physics-based Animations",
    "section": "Constraints",
    "text": "Constraints\nTesserax physics engine also supports some simple constraints like Springs (soft constraints) and Rods (hard constraints). These work by applying forces and corrections to bodies during simulation.\n\n\nCode\nfrom tesserax import Canvas, Rect, Circle, Line, Point\nfrom tesserax.animation import Scene\nfrom tesserax.physics import World, Gravity, Material\nfrom tesserax.physics.constraints import Spring, Rod\n\nwith Canvas() as canvas:\n    r1 = Rect(20, 20, fill=\"steelblue\").translated(50, 0)\n    ball = Circle(15, fill=\"orange\").translated(100, 0)\n    r2 = Rect(20, 20, fill=\"green\").translated(150, 0)\n\n    spring_line = Line(\n        lambda: r1.anchor(\"center\"),\n        lambda: ball.anchor(\"center\"),\n        stroke=\"gray\",\n        width=3,\n    )\n    rod_line = Line(\n        lambda: ball.anchor(\"center\"),\n        lambda: r2.anchor(\"center\"),\n        stroke=\"gray\",\n        width=3,\n    )\n\nworld = World()\nworld.fields.append(Gravity())\n\nbody_r1 = world.add(r1)\nbody_ball = world.add(\n    ball,\n    material=Material(restitution=0.8),\n    collider=CircleCollider(15),\n    static=True,\n)\nbody_r2 = world.add(r2)\nbody_r2.angular_vel = 5.0  # Radians/sec\n\n# Physics Constraint\nworld.constraint(Spring(body_r1, body_ball, length=30, k=50))\nworld.constraint(Spring(body_ball, body_r2, length=30, k=50))\n\n# 3. Bake\nsimulation = world.simulate(duration=5.0)\ncanvas.fit(10, bounds=simulation.bounds)\n\n# 4. Play\nscene = Scene(canvas)\nscene.play(simulation, duration=5.0)\nscene.display()"
  },
  {
    "objectID": "charts.html",
    "href": "charts.html",
    "title": "Statistical Visualizations (Altair-lite)",
    "section": "",
    "text": "While Tesserax is primarily a geometric engine, it includes a high-level Chart component for building statistical visualizations. Inspired by the Grammar of Graphics (and the Altair library), this API allows you to map data fields to visual channels like x, y, and color."
  },
  {
    "objectID": "charts.html#the-charting-philosophy",
    "href": "charts.html#the-charting-philosophy",
    "title": "Statistical Visualizations (Altair-lite)",
    "section": "The Charting Philosophy",
    "text": "The Charting Philosophy\nUnlike traditional plotting libraries that require complex configuration for axes and legends, the Tesserax Chart focuses on the Mapping:\n\nData: A list of dictionaries.\nMark: The geometric shape used to represent data (e.g., bar, point).\nEncoding: The connection between a data field and a visual property."
  },
  {
    "objectID": "charts.html#basic-bar-charts",
    "href": "charts.html#basic-bar-charts",
    "title": "Statistical Visualizations (Altair-lite)",
    "section": "Basic Bar Charts",
    "text": "Basic Bar Charts\nTo create a bar chart, you define your data, initialize a Chart, and chain the .bar() and .encode() methods.\nNote on Coordinates: The Chart component uses a “Chart Space” internally, where \\((0,0)\\) is at the bottom-left. Tesserax automatically handles the flip to SVG coordinates for you.\n\n\nCode\nfrom tesserax import Canvas, Chart, Colors\n\ndata = [\n    {\"category\": \"A\", \"value\": 45},\n    {\"category\": \"B\", \"value\": 90},\n    {\"category\": \"C\", \"value\": 65},\n    {\"category\": \"D\", \"value\": 30},\n]\n\nwith Canvas() as canvas:\n    # Initialize a chart with dimensions\n    chart = Chart(data, width=300, height=150)\n\n    # Configure the mark and the encoding\n    chart.bar(padding=0.2).encode(\n        x=\"category\",\n        y=\"value\",\n        color=\"category\"\n    )\n\ncanvas.fit(10).display()"
  },
  {
    "objectID": "charts.html#scatter-plots-point-marks",
    "href": "charts.html#scatter-plots-point-marks",
    "title": "Statistical Visualizations (Altair-lite)",
    "section": "Scatter Plots (Point Marks)",
    "text": "Scatter Plots (Point Marks)\nBy switching to .point(), you can create scatter plots or dot plots. You can control the size of the points via the mark parameters.\n\n\nCode\nimport random\n\n# Generate some random data\npoints = [{\"idx\": i, \"val\": random.uniform(10, 100)} for i in range(10)]\n\nwith Canvas() as canvas:\n    Chart(points, width=300, height=100).point(size=4).encode(x=\"idx\", y=\"val\")\n\ncanvas.fit(10).display()"
  },
  {
    "objectID": "charts.html#composability",
    "href": "charts.html#composability",
    "title": "Statistical Visualizations (Altair-lite)",
    "section": "Composability",
    "text": "Composability\nBecause a Chart is just another Tesserax Component, it can be transformed, rotated, or placed inside layouts just like a Rect or a Circle.\n\n\nCode\nfrom tesserax import deg\nfrom tesserax.layout import RowLayout\n\nwith Canvas() as canvas:\n    with RowLayout(gap=50):\n        # Chart 1: Bars\n        Chart(data, width=150, height=100).bar().encode(\n            x=\"category\", y=\"value\"\n        )\n\n        # Chart 2: Points (Rotated!)\n        Chart(data, width=150, height=100).point(size=5).encode(\n            x=\"category\", y=\"value\"\n        ).rotated(deg(45))\n\ncanvas.fit(20).display()"
  },
  {
    "objectID": "charts.html#how-scales-work-internally",
    "href": "charts.html#how-scales-work-internally",
    "title": "Statistical Visualizations (Altair-lite)",
    "section": "How Scales Work Internally",
    "text": "How Scales Work Internally\nTesserax automatically selects the appropriate Scale based on the data:\n\nLinearScale: Used for quantitative data (numbers) to map values to pixels.\nBandScale: Used for categorical data (strings) to distribute items evenly with padding.\nColorScale: Automatically assigns distinct colors from a professional palette when the color channel is encoded."
  },
  {
    "objectID": "charts.html#axes-and-gridlines",
    "href": "charts.html#axes-and-gridlines",
    "title": "Statistical Visualizations (Altair-lite)",
    "section": "Axes and Gridlines",
    "text": "Axes and Gridlines\nTesserax charts can automatically generate axes, labels, and gridlines. You can configure these using a simple shorthand or a more powerful structured encoding.\n\nBasic Axes\nThe .axis() method allows you to quickly add titles and toggle features like gridlines.\n\n\nCode\nwith Canvas() as canvas:\n    Chart(data, width=300, height=180) \\\n        .bar() \\\n        .encode(x=\"category\", y=\"value\") \\\n        .axis(\"x\", title=\"Category Name\") \\\n        .axis(\"y\", title=\"Sales ($)\", grid=True)\n\ncanvas.fit(10).display()\n\n\n\n\n\n\n\n\n\n\n\nStructured Encodings\nFor more control, you can use the X and Y classes within the .encode() method. This is more consistent with the Altair/Vega-Lite philosophy and allows for fine-grained configuration of the Axis object.\n\n\nCode\nfrom tesserax.chart import X, Y, Axis\n\nwith Canvas() as canvas:\n    Chart(data, width=300, height=180) \\\n        .point(size=6) \\\n        .encode(\n            x=X(\"category\", axis=Axis(title=\"City\")),\n            y=Y(\"value\", axis=Axis(title=\"Population\", grid=True))\n        )\n\ncanvas.fit(10).display()\n\n\n\n\n\n\n\n\n\nWhen axes are enabled, Tesserax automatically calculates margins to ensure labels and titles have enough space within the component’s bounding box."
  },
  {
    "objectID": "charts.html#chart-animations-enter-update-exit",
    "href": "charts.html#chart-animations-enter-update-exit",
    "title": "Statistical Visualizations (Altair-lite)",
    "section": "Chart Animations (Enter-Update-Exit)",
    "text": "Chart Animations (Enter-Update-Exit)\nTesserax supports reactive animations. When your data changes, the chart can automatically transition existing marks, animate new ones coming in, and gracefully remove old ones.\nThis follows the Enter-Update-Exit pattern:\n\nEnter: New data points (identified by a unique id or index) are created and animated into view.\nUpdate: Existing points move to their new positions and sizes.\nExit: Removed data points animate out before being detached from the scene.\n\nTo animate a chart, you use the chart.animate.data() method within a Scene.\n\n\nCode\nfrom tesserax.animation import Scene\n\n# Dataset 1: Initial state\ndata_v1 = [\n    {\"city\": \"New York\", \"sales\": 40, \"cat\": \"East\"},\n    {\"city\": \"Chicago\", \"sales\": 60, \"cat\": \"Central\"},\n    {\"city\": \"Los Angeles\", \"sales\": 50, \"cat\": \"West\"},\n]\n\n# Dataset 2: Chicago grows, LA moves to a new category,\n# NY is removed, and Houston enters.\ndata_v2 = [\n    {\"city\": \"Chicago\", \"sales\": 90, \"cat\": \"Central\"},\n    {\"city\": \"Los Angeles\", \"sales\": 50, \"cat\": \"West\"}, # Category changed!\n    {\"city\": \"Houston\", \"sales\": 45, \"cat\": \"East\"},     # New entry\n]\n\nwith Canvas() as canvas:\n    # We define the chart with 'city' as the natural ID\n    chart = Chart(data_v1, width=400, height=200) \\\n        .bar() \\\n        .encode(x=\"city\", y=\"sales\", color=\"cat\") \\\n        .axis(\"x\", title=\"City\") \\\n        .axis(\"y\", title=\"Sales\", grid=True)\n\nscene = Scene(canvas.fit(10))\nscene.play(chart.animate.data(data_v2).pad(0.2, 0.5), duration=2)\n\nscene.display()\n\n\n\n\n\n\nHow Identity Works\nTesserax needs to know which data point corresponds to which visual mark to animate them correctly. It determines identity in this order:\n\nChecking for an explicit _id or id field in the row.\nChecking the field encoded to the x channel (if it’s a string or integer).\nFalling back to the row index in the list."
  },
  {
    "objectID": "animations.html",
    "href": "animations.html",
    "title": "Animation & Video",
    "section": "",
    "text": "Tesserax isn’t just for static images. It includes a lightweight, code-first animation engine capable of exporting GIFs and MP4s."
  },
  {
    "objectID": "animations.html#the-scene-object",
    "href": "animations.html#the-scene-object",
    "title": "Animation & Video",
    "section": "The Scene Object",
    "text": "The Scene Object\nThe Scene is the director of your animation. It wraps a Canvas and manages the render loop, frame capture, and file export.\nAt its lowest level, you can animate simply by changing shapes in a loop and calling scene.capture(). This gives you total control over every frame.\n\n\nCode\nfrom tesserax import Canvas, Square, deg\nfrom tesserax.animation import Scene\nfrom tesserax.color import Colors\n\n# 1. Setup the static scene\nwith Canvas() as canvas:\n    rect = Square(40, fill=Colors.Orange)\n\ncanvas.fit(10)\n\n# 2. Animate\nscene = Scene(canvas, fps=30)\n\n# We manually drive the loop\nfor i in range(30):\n    rect.rotated(deg(3)) # Rotate 3 degrees per frame\n    scene.capture()      # Snap!\n\n# 3. Render\nscene.display()"
  },
  {
    "objectID": "animations.html#declarative-animations",
    "href": "animations.html#declarative-animations",
    "title": "Animation & Video",
    "section": "Declarative Animations",
    "text": "Declarative Animations\nWhile manual loops are powerful, they get messy quickly. Tesserax provides a declarative API where you define what happens, not how.\nThe Scene.play() method accepts one or more Animation objects.\n\nParallel: Arguments passed to play(a, b) run simultaneously.\nSequential: Animations added with a + b run one after another.\n\nWe use the .animate property on shapes to quickly generate these objects.\n\n\nCode\nfrom tesserax import Circle\n\nwith Canvas() as canvas:\n    box = Square(30, fill=Colors.LightBlue).translated(-40, 0)\n    ball = Circle(15, fill=Colors.Salmon).translated(40, 0)\n\ncanvas.fit(10)\nscene = Scene(canvas, fps=30)\n\n# Define animations\nmove_box = box.animate.rotate(deg(90)) | box.animate.translate(20)\nfade_ball = ball.animate.scale(0.5)\n\n# Run them together (box moves sequentially, ball scales in parallel)\nscene.play(move_box.looping(), fade_ball.looping(), duration=2.0)\n\nscene.display()\n\n\n\n\n\n\nAnimation Modifiers\nYou can tweak the timing and behavior of any animation using fluent modifiers:\n\n.reversed(): Plays backwards.\n.looping(): Plays forward then backward (yoyo).\n.repeating(n): Repeats n times within the duration.\n.delayed(t): Waits for t (0.0 to 1.0) before starting.\n.smoothed(): Applies an ease-in-out curve (default is linear).\n\n\n\nCode\nfrom tesserax import Shape\n\nwith Canvas() as c:\n    b1 = Circle(10, fill=Colors.Red).translated(-30, 0)\n    b2 = Circle(10, fill=Colors.Blue).translated(0, 0)\n    b3 = Circle(10, fill=Colors.Green).translated(30, 0)\n\nc.fit(40)\nscene = Scene(c)\n\n# Create a jump animation\ndef jump(shape: Shape):\n    return (\n        shape.animate.translate(0, -40).smoothed() |\n        shape.animate.translate(0, 0).smoothed()\n    )\n\nscene.play(\n    jump(b1),\n    jump(b2).delayed(0.2), # Start 20% later\n    jump(b3).delayed(0.4), # Start 40% later\n    duration=1.5\n)\n\nscene.display()"
  },
  {
    "objectID": "animations.html#morphing-and-warping",
    "href": "animations.html#morphing-and-warping",
    "title": "Animation & Video",
    "section": "Morphing and Warping",
    "text": "Morphing and Warping\nFor Polyline shapes, Tesserax offers advanced vertex manipulation.\n\nMorphing\nThe .morph(target) animation smoothly interpolates the points of one shape into another.\n\n\nCode\nfrom tesserax import Polyline\n\nwith Canvas() as c:\n    # Start as a Triangle\n    shape = Polyline.poly(3, 40, fill=Colors.Gold).subdivide()\n    # Target is a Hexagon\n    target = Polyline.poly(6, 40).hide()\n\nc.fit(10)\nscene = Scene(c)\n\nscene.play(\n    shape.animate.morph(target).smoothed().looping(),\n    duration=2.0\n)\n\nscene.display()\n\n\n\n\n\n\n\nWarping\nThe .warp(func) animation allows you to apply a function to every point in a shape over time. This is perfect for wave effects.\n\n\nCode\nimport math\nfrom tesserax import Point\n\nwith Canvas() as c:\n    # Create a dense line so we have points to warp\n    line = Polyline([Point(x, 0) for x in range(-50, 50, 2)], stroke=Colors.Blue)\n\nc.fit(15)\nscene = Scene(c)\n\n# Define a wave function\ndef wave(p, t):\n    # t goes 0 -&gt; 1\n    # We use it to shift the phase\n    phase = t * math.pi * 2\n    amplitude = 10\n    freq = 0.1\n    return Point(p.x, math.sin(p.x * freq + phase) * amplitude)\n\nscene.play(\n    line.animate.warp(wave).repeating(2),\n    duration=2.0\n)\n\ncanvas.fit(10)\nscene.display()"
  },
  {
    "objectID": "animations.html#text-effects",
    "href": "animations.html#text-effects",
    "title": "Animation & Video",
    "section": "Text Effects",
    "text": "Text Effects\nText objects have their own special animator with effects like write (typewriter style) and scramble (hacker style).\n\n\nCode\nfrom tesserax import Text\n\nwith Canvas() as c:\n    t1 = Text(\"Hello World\", size=24).translated(0, -20)\n    t2 = Text(\"Encryption\", size=24, fill=Colors.Green, font=\"monospace\").translated(0, 20)\n\nc.fit(10)\nscene = Scene(c)\n\nscene.play(\n    t1.animate.write(),\n    t2.animate.scramble(),\n    duration=2.0\n)\nscene.wait(1.0)\n\nscene.display()"
  },
  {
    "objectID": "animations.html#animating-arbitrary-properties",
    "href": "animations.html#animating-arbitrary-properties",
    "title": "Animation & Video",
    "section": "Animating Arbitrary Properties",
    "text": "Animating Arbitrary Properties\nSometimes you need to animate a property that Tesserax doesn’t have a built-in method for, like the radius of a circle, the gap of a layout, or a custom attribute you added to a subclass.\n\nThe property Method\nThe animator.property(name, value) method allows you to interpolate any numeric attribute on the shape from its current value to a target value.\n\n\nCode\nfrom tesserax import Circle\n\nwith Canvas() as c:\n    # A circle starts with radius 10\n    ball = Circle(10, fill=Colors.Red)\n\nc.fit(15)\nscene = Scene(c)\n\nscene.play(\n    # Explicitly animate the 'r' attribute (radius) to 50\n    ball.animate.property(\"r\", 20).looping(),\n    duration=1.0\n)\nscene.display()\n\n\n\n\n\n\n\nMagic Property Access\nFor even cleaner code, the animator supports dynamic property access. If you try to call a method on .animate that doesn’t exist (e.g., .radius(...)), Tesserax assumes you want to animate the property of that name.\nAnd since any property can be animated (as long as the underlying value supports scalar arithmetics), you can funny things like animating the smoothness of a Polyline.\n\n\nCode\nfrom tesserax import Polyline\n\nwith Canvas() as c:\n    # Square defined by 'size'\n    line = Polyline.poly(5, 50)\n\nc.fit(10)\nscene = Scene(c)\n\nscene.play(\n    line.animate.width(5).looping(),\n    line.animate.smoothness(1).looping(),\n    line.animate.rotate(deg(360/5)).smoothed(),\n    duration=1.0\n)\nscene.display()"
  },
  {
    "objectID": "animations.html#custom-animation-logic",
    "href": "animations.html#custom-animation-logic",
    "title": "Animation & Video",
    "section": "Custom Animation Logic",
    "text": "Custom Animation Logic\nWhen standard interpolation isn’t enough, the .custom() method gives you a direct hook into the animation loop. You provide a callback function that receives the shape and the time (from 0 to 1), and you can do whatever you want.\nThis is perfect for complex math, interdependent properties, or non-linear behaviors. The fun part is that you add .looping() or .smoothed() or any other standard Animation modifier even to these custom animations.\n\n\nCode\nimport math\n\nwith Canvas() as c:\n    ball = Circle(10, fill=Colors.Purple)\n\nc.fit(50)\nscene = Scene(c)\n\n# A custom function to move in a spiral\ndef spiral(shape, t):\n    # t goes 0 -&gt; 1\n    angle = t * math.pi * 4  # 2 full turns\n    radius = t * 50          # Spiral out to 50px\n\n    # Update position manually\n    shape.transform.tx = math.cos(angle) * radius\n    shape.transform.ty = math.sin(angle) * radius\n\n    # We can also change other properties!\n    shape.fill = Colors.Purple.lerp(Colors.Yellow, t)\n\nscene.play(\n    ball.animate.custom(spiral).smoothed().looping(),\n    duration=3.0\n)\n\nscene.display()"
  },
  {
    "objectID": "animations.html#keyframe-animation",
    "href": "animations.html#keyframe-animation",
    "title": "Animation & Video",
    "section": "Keyframe Animation",
    "text": "Keyframe Animation\nFor complex motion graphics where an object needs to follow a specific “script” (e.g., “move right, wait, rotate, then shrink”), chaining simple animations becomes tedious.\nThe .keyframes() method allows you to define a timeline for multiple properties simultaneously in a single call.\n\nThe Timeline API\nYou pass properties as keyword arguments. Each argument accepts a dictionary mapping a normalized time (\\(0.0 \\to 1.0\\)) to a target value.\n\nIf \\(0.0\\) is missing, Tesserax infers it from the current state.\nTesserax automatically detects if the property belongs to the Shape (like fill) or its Transform (like tx, rotation).\n\n\n\nCode\nfrom tesserax.animation import ease_out, ease_in_out_cubic, linear\n\nwith Canvas() as c:\n    box = Square(30, fill=Colors.Orange)\n\nc.fit(50)\nscene = Scene(c)\n\nscene.play(\n    box.animate.keyframes(\n        # Track 1: Movement (Transform property)\n        tx={\n            0.0: -20,\n            0.4: 20, # Move fast to 100\n            0.6: 20, # Stay there for 20% of time\n            1.0: -20,    # Return home\n        },\n        # Track 2: Rotation (Transform property)\n        # We can use (value, easing) tuples for precise control\n        rotation={\n            0.0: 0,\n            1.0: (deg(360), ease_in_out_cubic) # Spin fully with smooth accel/decel\n        },\n        # Track 3: Color (Shape property)\n        fill={\n            0.5: Colors.Orange,\n            0.8: Colors.Red, # Turn red near the end\n            1.0: Colors.Orange\n        }\n    ),\n    duration=3.0\n)\n\nscene.display()\n\n\n\n\n\nBy default, Tesserax interpolates linearly between keyframes. However, you often want specific segments to feel different (e.g., a “snap” effect).\nYou can pass a tuple (value, easing_function) instead of just a raw value. The easing function applies to the time interval leading up to that keyframe."
  },
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "Core Concepts & Primitives",
    "section": "",
    "text": "Tesserax is designed to be a “thin layer” of geometric logic over SVG. Unlike plotting libraries that try to decide for you how axes and scales should work, Tesserax gives you a blank canvas and a set of precise drafting tools.\nThis guide covers the fundamental building blocks: the coordinate system, basic shapes, transformations, the anchor system, and the powerful Polyline API."
  },
  {
    "objectID": "core.html#the-canvas-and-coordinates",
    "href": "core.html#the-canvas-and-coordinates",
    "title": "Core Concepts & Primitives",
    "section": "The Canvas and Coordinates",
    "text": "The Canvas and Coordinates\nEvery diagram begins with a Canvas. In Tesserax, the Canvas serves two roles:\n\nContainer: It collects all shapes created within its context.\nViewport: It manages the final SVG bounding box and coordinate mapping.\n\n\nMathematical Coordinate System\nTesserax follows the standard SVG Coordinate System:\n\nThe origin \\((0, 0)\\) is at the top-left corner (initially).\nThe X-axis points to the right (\\(+x\\)).\nThe Y-axis points down (\\(+y\\)).\n\nThis is crucial to remember when applying rotations. A positive rotation (counter-clockwise) moves the \\(+x\\) axis towards the \\(+y\\) axis (downwards on the screen).\n\n\nCode\nfrom tesserax import Canvas, Rect, Text\nfrom tesserax.color import Colors\n\nwith Canvas() as canvas:\n    # A simple reference grid\n    Rect(100, 100, stroke=Colors.LightGray, fill=Colors.White)\n\n    # Origin marker\n    Text(\"(0,0)\", size=20)\n\n    # Positive X/Y indication\n    Text(\"+X\", size=20).translated(70, 0)\n    Text(\"+Y\", size=20).translated(0, 70)\n\ncanvas.fit(5).display()"
  },
  {
    "objectID": "core.html#basic-primitives",
    "href": "core.html#basic-primitives",
    "title": "Core Concepts & Primitives",
    "section": "Basic Primitives",
    "text": "Basic Primitives\nTesserax provides a suite of geometric atoms. All visual shapes inherit from the Visual class, which standardizes properties like fill, stroke, and width.\n\nRectangles and Circles\n\nRect(w, h): Defined by width and height. Centered at by default.\nSquare(size): A convenience wrapper for Rect.\nCircle(r): Defined by radius. Centered at .\nEllipse(rx, ry): Defined by horizontal and vertical radii.\n\n\n\nCode\nfrom tesserax import Canvas, Rect, Square, Circle, Ellipse\n\nwith Canvas() as c:\n    # Shapes are placed at (0,0) by default, so we translate them to separate them.\n    Square(40, fill=Colors.LightBlue).translated(0, 0)\n    Rect(60, 30, fill=Colors.LightGreen).translated(60, 0)\n    Circle(20, fill=Colors.Salmon).translated(120, 0)\n    Ellipse(20, 10, fill=Colors.Plum).translated(170, 0)\n\nc.fit(10).display()\n\n\n\n\n\n\n\n\n\n\n\nText and Alignment\nText in SVG can be tricky due to alignment issues. Tesserax simplifies this by defaulting to center/middle alignment.\nYou can control this via:\n\nanchor: Horizontal alignment (\"start\", \"middle\", \"end\").\nbaseline: Vertical alignment (\"top\", \"middle\", \"bottom\").\n\n\n\nCode\nfrom tesserax import Text, Line, Point\n\nwith Canvas() as c:\n    # Draw a crosshair at the origin to show alignment\n    Line(Point(0, -20), Point(0, 20), stroke=Colors.LightGray)\n    Line(Point(-50, 0), Point(50, 0), stroke=Colors.LightGray)\n\n    # Default Text (Centered)\n    Text(\"Origin\", size=16, fill=Colors.Black)\n\n    # Custom alignment\n    Text(\"Top-Left\", anchor=\"end\", baseline=\"bottom\").translated(-20, -20)\n    Text(\"Bottom-Right\", anchor=\"start\", baseline=\"top\").translated(20, 20)\n\nc.fit(10).display()"
  },
  {
    "objectID": "core.html#the-transformation-model",
    "href": "core.html#the-transformation-model",
    "title": "Core Concepts & Primitives",
    "section": "The Transformation Model",
    "text": "The Transformation Model\nEvery shape in Tesserax carries a Transform object. This defines an Affine Transformation that maps the shape’s local coordinate space to the parent space.\nThe operation order is strict: Scale - Rotate - Translate.\n\nScale: The object is stretched.\nRotate: The object is rotated around the (scaled) origin.\nTranslate: The object is moved to its final position.\n\nTesserax provides a fluent API to chain these operations:\n\n\nCode\nfrom tesserax import Canvas, Rect, deg\n\nwith Canvas() as c:\n    # 1. Create a rectangle at (0,0)\n    r = Rect(50, 30, fill=Colors.LightBlue, stroke=Colors.Blue)\n\n    # 2. Scale it by 1.5x\n    # 3. Rotate it by 45 degrees\n    # 4. Move it to (50, 50)\n    r.scaled(1.5).rotated(deg(45)).translated(50, 50)\n\n    # Show the origin for reference\n    Circle(2, fill=Colors.Red).translated(50, 50)\n\nc.fit(20).display()"
  },
  {
    "objectID": "core.html#the-anchor-system",
    "href": "core.html#the-anchor-system",
    "title": "Core Concepts & Primitives",
    "section": "The Anchor System",
    "text": "The Anchor System\nOne of Tesserax’s most powerful features is semantic anchoring. Because shapes are often nested inside Groups or transformed heavily, calculating the exact coordinate of “the top-right corner of that rotated rectangle” is mathematically tedious.\nThe .anchor(name) method solves this by resolving the local coordinate through the entire transformation stack.\nAvailable anchors: center, top, bottom, left, right, topleft, topright, bottomleft, bottomright.\n\n\nCode\nfrom tesserax import Arrow\n\nwith Canvas() as c:\n    # A generic shape\n    obj = Rect(60, 40, fill=Colors.Honeydew, stroke=Colors.Green)\n    obj.rotated(deg(30)).translated(50, 50)\n\n    # A target point\n    target = Circle(5, fill=Colors.Red).translated(150, 50)\n\n    # Connect the top-right corner of the rotated rect to the target\n    # We don't need to know where \"top-right\" is in global space,\n    # .anchor() calculates it.\n    Arrow(obj.anchor(\"topright\"), target.anchor(\"center\"))\n\nc.fit(20).display()"
  },
  {
    "objectID": "core.html#paths-and-lines",
    "href": "core.html#paths-and-lines",
    "title": "Core Concepts & Primitives",
    "section": "Paths and Lines",
    "text": "Paths and Lines\nFor arbitrary drawing, Tesserax offers both low-level and high-level path tools.\n\nThe Low-Level Path\nThe Path class maps directly to SVG commands (M, L, C, Q, Z).\n\n\nCode\nfrom tesserax import Path\n\nwith Canvas() as c:\n    p = Path(fill=Colors.Transparent, stroke=Colors.Blue, width=2)\n    p.jump_to(0, 0)\n    p.line_to(50, 50)\n    p.quadratic_to(100, 50, 100, 0) # Control point (100,50), End (100,0)\n\nc.fit(10).display()\n\n\n\n\n\n\n\n\n\n\n\nLines and Arrows\nLine and Arrow are specialized paths that connect two points. They support a curvature parameter to create arcs without manually calculating Bezier control points.\n\n\nCode\nfrom tesserax import Line\n\nwith Canvas() as c:\n    start, end = Point(0, 0), Point(100, 0)\n\n    Line(start, end, curvature=0, stroke=Colors.LightGray) # Straight\n    Line(start, end, curvature=0.5, stroke=Colors.Blue)   # Arc Up\n    Arrow(start, end, curvature=-0.5, stroke=Colors.Red)  # Arc Down\n\nc.fit(30).display()"
  },
  {
    "objectID": "core.html#the-polyline-api",
    "href": "core.html#the-polyline-api",
    "title": "Core Concepts & Primitives",
    "section": "The Polyline API",
    "text": "The Polyline API\nThe Polyline is a versatile tool for creating complex polygons, wireframes, and smooth curves. It maintains a list of Point objects and renders them sequentially.\n\nSmoothing and Rounding\nThe smoothness parameter (\\(0\\) to \\(1\\)) automatically converts sharp vertices into rounded corners using quadratic Bezier interpolation.\n\n\nCode\nfrom tesserax import Polyline\n\npts = [Point(0, 0), Point(50, 50), Point(100, 0), Point(150, 50)]\n\nwith Canvas() as c:\n    # Sharp (0.0)\n    Polyline(pts, smoothness=0, stroke=Colors.Black).translated(0, 0)\n\n    # Rounded (0.5)\n    Polyline(pts, smoothness=0.5, stroke=Colors.Blue).translated(0, 60)\n\n    # Fluid (1.0)\n    Polyline(pts, smoothness=1.0, stroke=Colors.Red).translated(0, 120)\n\nc.fit(10).display()\n\n\n\n\n\n\n\n\n\n\n\nProcedural Generation\nThe Polyline class includes powerful methods to procedurally generate and manipulate shapes.\n\nPolyline.poly(n, radius): Creates a regular n-gon (triangle, hexagon, etc.).\n.subdivide(n): Inserts midpoints between every segment, increasing resolution.\n.simplify(tolerance): Removes points that are collinear or redundant.\n.expand(delta): Pushes points away from the origin (inflation).\n.apply(func): Maps a function over every point.\n\n\n\nCode\nimport math\n\nwith Canvas() as c:\n    # 1. Create a Hexagon\n    hex = Polyline.poly(n=6, radius=40, fill=Colors.AliceBlue)\n    hex.translated(50, 50)\n\n    # 2. Create a \"Wobbly\" Circle\n    # Start with a simple polygon, subdivide it to get many vertices,\n    # then apply a noise function to the radius.\n    blob = Polyline.poly(n=8, radius=40, fill=Colors.MistyRose, smoothness=1)\n    blob.subdivide(3) # Increase vertex count 8 -&gt; 16 -&gt; 32 -&gt; 64\n\n    # Apply a wave function to distort it\n    def distort(p: Point) -&gt; Point:\n        # Get angle of point\n        theta = math.atan2(p.y, p.x)\n        # Vary radius based on angle\n        wave = math.sin(theta * 5) * 5\n        return p + p.normalize() * wave\n\n    blob.apply(distort).simplify(0.1)\n    blob.translated(150, 50)\n\n    # 3. Contract/Expand\n    # Useful for creating outlines or offsets\n    base = Polyline.poly(4, 30, stroke=Colors.Black)\n    inner = base.clone().contract(5) # Shrink\n\n    base.translated(250, 50)\n    inner.translated(250, 50)\n\nc.fit(10).display()"
  },
  {
    "objectID": "core.html#sketchy-drawings",
    "href": "core.html#sketchy-drawings",
    "title": "Core Concepts & Primitives",
    "section": "Sketchy Drawings",
    "text": "Sketchy Drawings\nAnd since mathematical drawings are incomplete without an XKCD-style sketchy mode, Tesserax also provides a (still kinda ugly) implementation for sketches. You can use it just as a regular group, but everything drawn inside will be sketched (if possible).\n\n\nCode\nfrom tesserax.sketch import Sketch\n\nwith Canvas() as canvas:\n    with Sketch() as g:\n        r = Rect(50, 100, stroke=Colors.Red, width=2)\n        c = Circle(50, stroke=Colors.Green, width=2)\n        q = Square(75, stroke=Colors.Blue, width=2)\n\n    g.distribute(\"horizontal\", gap=25)\n\ncanvas.fit(10).display()\n\n\n\n\n\n\n\n\n\nNot all Tesserax primitives can be sketched. For this to work, we need to be able to compute Paths for a given shape, which is not possible for non-procedural shapes like Text and Sprite. Also, curved shapes like Arrow are not supported yet, but you can subsititute those with custom Polyline with end markers. Also, sketches currently don’t work with fill colors."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Tesserax: A Lightweight SVG Rendering Library",
    "section": "",
    "text": "Tesserax is a modern Python 3.12 library designed for programmatic SVG generation with a focus on ease of use, layout management, and flexible geometric primitives. It is particularly well-suited for visualizing data structures, algorithms, and technical diagrams.\nBeyond static diagrams, Tesserax now includes a deterministic physics engine and a cinematic animation system, making it a complete toolkit for scientific communication."
  },
  {
    "objectID": "index.html#key-features",
    "href": "index.html#key-features",
    "title": "Tesserax: A Lightweight SVG Rendering Library",
    "section": "Key Features",
    "text": "Key Features\n\nRich Primitives: Includes standard shapes (Rect, Circle) plus advanced procedural geometry like Polyline with smoothing and subdivision support.\nDeclarative Layouts: Effortlessly arrange shapes in Row, Column, or Grid containers, or use algorithmic layouts like Tree and Force.\nSmart Canvas: Automatically fit the canvas viewport to the content with adjustable padding.\nAnchor System: Connect shapes using semantic anchors like top, bottom, left, right, and center.\nCinematic Animations: Create complex motion graphics using a declarative, code-first API that supports keyframes, morphing, and warping.\nPhysics Simulation: Bake high-precision rigid body simulations directly into your animations using the built-in World and Body primitives.\nStatistical Visualization: Build data-driven graphics with an Altair-inspired API that decouples marks and encodings."
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "Tesserax: A Lightweight SVG Rendering Library",
    "section": "Installation",
    "text": "Installation\nTesserax has zero dependencies (literally). It’s 100% pure Python, and can be easily installed with pip:\npip install tesserax\nOr if you’re one of the cool kids, using uv:\nuv add tesserax\nIf you want support for saving PNG files, install with the export extra:\npip install tesserax[export]"
  },
  {
    "objectID": "index.html#quick-start",
    "href": "index.html#quick-start",
    "title": "Tesserax: A Lightweight SVG Rendering Library",
    "section": "Quick Start",
    "text": "Quick Start\nTo showcase how Tesserax works, we’ll build a small illustration step by step. We will start with a blank canvas and gradually add layers of complexity, from simple text to automated layouts and animations.\n\nStep 1: The Canvas and Text\nFirst, we initialize the Canvas and add the central Text element. The Canvas acts as our root container.\n\n\nCode\nfrom tesserax import Canvas, Text\nfrom tesserax.color import Colors\n\nwith Canvas() as canvas:\n    t = Text(\n        \"tesserax\",\n        size=48,\n        font=\"sans-serif\",\n        fill=Colors.Navy,\n        anchor=\"middle\",\n    )\n\ncanvas.fit().display()\n\n\n\n\n\n\n\n\n\n\n\nStep 2: Adding Geometric Shapes\nNext, we add a Square and a Circle. At this stage, we create them without specific coordinates.\n\n\nCode\nfrom tesserax import Square, Circle\nfrom tesserax.color import Colors\n\nwith canvas:\n    r = Square(30, fill=Colors.Green, stroke=Colors.Transparent).translated(-120, 0)\n    c = Circle(20, fill=Colors.Red, stroke=Colors.Transparent).translated(120, 0)\n\ncanvas.fit().display()\n\n\n\n\n\n\n\n\n\n\n\nStep 3: Distribution with Groups\nWe can arrange these elements more easily with a Group. Groups can reorganize their inner shapes with align and distribute.\n\n\nCode\nfrom tesserax import Group\n\nwith Canvas() as canvas:\n    with Group() as g:\n        r = Square(30, fill=Colors.Green, stroke=Colors.Transparent)\n        t = Text(\n            \"tesserax\",\n            size=48,\n            font=\"sans-serif\",\n            fill=Colors.Navy,\n            anchor=\"middle\",\n        )\n        c = Circle(20, fill=Colors.Red, stroke=Colors.Transparent)\n\n    g.align(\"horizontal\").distribute(\"horizontal\")\n\ncanvas.fit(10).display()\n\n\n\n\n\n\n\n\n\n\n\nStep 3a: Using Layouts\nAn alternative is to use Layout subclasses like RowLayout, which automates this logic.\n\n\nCode\nfrom tesserax.layout import RowLayout\n\nwith Canvas() as canvas:\n    with RowLayout() as logo:\n        r = Square(30, fill=Colors.Green, stroke=Colors.Transparent)\n        t = Text(\n            \"tesserax\",\n            size=48,\n            font=\"sans-serif\",\n            fill=Colors.Navy,\n            anchor=\"middle\",\n        )\n        c = Circle(20, fill=Colors.Red, stroke=Colors.Transparent)\n\ncanvas.fit().display()\n\n\n\n\n\n\n\n\n\n\n\nStep 4: Adding the Underline\nWe use the semantic anchor system to draw a Polyline connecting the shapes.\n\n\nCode\nfrom tesserax import Polyline\n\nwith canvas:\n    p = Polyline(\n        points=[r.anchor(\"bottom\").dy(10), c.anchor(\"bottom\").dy(10)],\n        smoothness=1.0,\n        stroke=Colors.Black,\n        marker_end=\"arrow\"\n    )\n\ncanvas.fit(5).display()\n\n\n\n\n\n\n\n\n\n\n\nStep 5: Making a Squiggly Line\nWe can use subdivide and apply on the Polyline to creating a procedurally generated curve.\n\n\nCode\nimport math\n\np.subdivide(7).apply(\n    lambda p: p.dy(math.sin((p.x / logo.bounds().width * 20 + 5)) * 5)\n)\n\ncanvas.fit(10).display()\n\n\n\n\n\n\n\n\n\n\n\nStep 6: Animating the Logo\nFinally, we use a Scene to animate the logo using the declarative fluent API.\n\n\nCode\nfrom tesserax.animation import Scene\nfrom tesserax import deg\n\nscene = Scene(canvas)\nscene.play(\n    r.animate.rotate(deg(90)),\n    c.animate.translate(-10, 0) | c.animate.translate(0, 0),\n    p.animate.warp(\n        lambda p, t: p.dy(\n            math.sin(p.x / logo.bounds().width * 20 + t * math.pi * 2) * 5\n        )\n    ),\n    duration=1,\n)\n\nscene.display()"
  },
  {
    "objectID": "index.html#deep-dive-beyond-the-basics",
    "href": "index.html#deep-dive-beyond-the-basics",
    "title": "Tesserax: A Lightweight SVG Rendering Library",
    "section": "Deep Dive: Beyond the Basics",
    "text": "Deep Dive: Beyond the Basics\nTesserax scales from simple scripts to complex simulations. Here is an overview of the advanced capabilities available.\n\nGeometric Primitives & Procedural Shapes\nTesserax provides a robust suite of atoms like Rect, Circle, Ellipse, and Arrow.\n\nPolyline API: The Polyline class supports smoothing (Bezier interpolation), subdivision (increasing resolution), and simplification (reducing vertices).\nPath API: For low-level control, use the Path class with standard SVG commands (move_to, cubic_to, arc).\n\n\n\nThe Layout Engine\nForget manual pixel pushing. Tesserax offers a hierarchy of layout engines:\n\nStandard Layouts: Row, Column, and Grid automatically position elements based on gaps and alignment.\nHierarchical Layout: Automatically draws Trees and Directed Acyclic Graphs (DAGs).\nForce-Directed Layout: Simulates physical forces to arrange arbitrary network graphs.\n\n\n\nCinematic Animation\nThe animation system is designed for storytelling, not just movement.\n\nDeclarative API: Compose animations using parallel (|) and sequential (+) operators.\nKeyframes: Define complex multi-stage timelines for any property (position, rotation, color).\nMorphing & Warping: Smoothly transform one shape into another or apply wave functions to geometry.\n\n\n\nPhysics Engine\nTesserax includes a baked physics engine for high-precision rigid body simulations.\n\nDeterministic: Define a World, add Body objects, and apply Fields like Gravity or Drag.\nBaked Playback: The simulation is calculated upfront and converted into standard keyframes, allowing high-resolution physics (e.g., 1000 steps/sec) to play back smoothly at any framerate.\nInteroperable: Physics animations can be mixed and matched with standard tweens.\n\n\n\nStatistical Visualization\nBridging the gap between diagrams and plots, Tesserax offers a grammar-of-graphics charting API.\n\nAltair-lite API: Define a Chart, select a Mark (bar, point), and encode visual channels like x, y, and color.\nAutomated Scales: Includes built-in Linear, Band, and Color scales that automatically map data values to pixels and palettes.\nIntegrated Axes: Effortlessly add titles, ticks, and gridlines with smart coordinate management."
  },
  {
    "objectID": "index.html#why-tesserax",
    "href": "index.html#why-tesserax",
    "title": "Tesserax: A Lightweight SVG Rendering Library",
    "section": "Why Tesserax?",
    "text": "Why Tesserax?\nIn the Python ecosystem, there is a clear divide between data visualization (plotting numbers) and diagrammatic representation (drawing concepts).\nTesserax is for Scientific Drawing—providing the low-level primitives needed for total layout authority.\nLibraries like Matplotlib map data to charts. Tesserax maps concepts to geometry. Use Tesserax for the schematics, geometric proofs, and algorithmic walkthroughs in your papers.\nTikZ is the industry standard for academic figures but uses a cryptic macro language. Tesserax brings that same “total-control” philosophy to Python 3.12, giving you coordinate-invariant precision with the power of Python’s loops and types."
  },
  {
    "objectID": "index.html#contribution",
    "href": "index.html#contribution",
    "title": "Tesserax: A Lightweight SVG Rendering Library",
    "section": "Contribution",
    "text": "Contribution\nTesserax is free as in both free beer and free speech. License is MIT.\nContributions are always welcomed! Fork, clone, and submit a pull request."
  }
]