[
  {
    "objectID": "layout.html",
    "href": "layout.html",
    "title": "Layouts & Composition",
    "section": "",
    "text": "While you can position every shape manually using .translated(x, y), Tesserax shines when you let it handle the geometry for you. The layout system is built on a hierarchy of abstractions, starting from simple groups and moving up to force-directed graph algorithms."
  },
  {
    "objectID": "layout.html#grouping-objects",
    "href": "layout.html#grouping-objects",
    "title": "Layouts & Composition",
    "section": "Grouping Objects",
    "text": "Grouping Objects\nThe Group class is the fundamental unit of composition. It treats a collection of shapes as a single object, allowing you to transform them together.\n\nThe Context Manager Pattern\nThe most idiomatic way to create a group is with the with statement.\n\n\nCode\nfrom tesserax import Canvas, Group, Rect, Circle, Text\nfrom tesserax.color import Colors\n\nwith Canvas() as c:\n    # A group acts as a local container\n    with Group() as g:\n        Rect(100, 100, fill=Colors.LightBlue)\n        Text(\"Group 1\")\n\n    # You can transform the entire group at once\n    g.translated(50, 50)\n\n    with Group() as g2:\n        Circle(30, fill=Colors.Salmon)\n\n    g2.translated(150, 50)\n\nc.fit(10).display()"
  },
  {
    "objectID": "layout.html#manual-layouts-align-and-distribute",
    "href": "layout.html#manual-layouts-align-and-distribute",
    "title": "Layouts & Composition",
    "section": "Manual Layouts: Align and Distribute",
    "text": "Manual Layouts: Align and Distribute\nBefore reaching for a full layout engine, you can often get what you need using the procedural API on Group.\n\n.align(axis, anchor): Aligns all children along an axis relative to the first child.\n.distribute(axis, gap, mode): Spaces children out evenly.\n\n\n\nCode\nfrom tesserax import Square\n\nwith Canvas() as c:\n    with Group() as g:\n        Square(20, fill=Colors.Red)\n        Square(30, fill=Colors.Green)\n        Square(40, fill=Colors.Blue)\n\n    # 1. Align centers vertically\n    g.align(\"vertical\", anchor=\"center\")\n\n    # 2. Distribute horizontally with 10px gap\n    g.distribute(\"horizontal\", gap=10)\n\n    g.translated(50, 50)\n\nc.fit(10).display()"
  },
  {
    "objectID": "layout.html#standard-layouts",
    "href": "layout.html#standard-layouts",
    "title": "Layouts & Composition",
    "section": "Standard Layouts",
    "text": "Standard Layouts\nStandard layouts like Row and Column are specialized Groups that automatically apply alignment and distribution logic when they are closed.\n\nRow and Column\nThese layouts are perfect for linear arrangements. They can be nested arbitrarily.\n\n\nCode\nfrom tesserax.layout import RowLayout, ColumnLayout\n\nwith Canvas() as c:\n    # A Row automatically distributes horizontally\n    with RowLayout(gap=10, align=\"middle\") as row:\n        Rect(20, 40, fill=Colors.LightGray)\n        Circle(15, fill=Colors.MistyRose)\n        Rect(20, 20, fill=Colors.LightCoral)\n\n        # A Column automatically distributes vertically\n        # Notice we can nest layouts\n        with ColumnLayout(gap=10, align=\"middle\") as col:\n            Rect(40, 20, fill=Colors.PowderBlue)\n            Circle(15, fill=Colors.Thistle)\n\nc.fit(10).display()\n\n\n\n\n\n\n\n\n\n\n\nThe Grid Layout\nThe Grid layout provides a powerful 2D arrangement system. Unlike a simple HTML table, the Tesserax Grid allows for spanning and alignment control per cell.\n\n\nCode\nfrom tesserax.layout import GridLayout\n\nwith Canvas() as c:\n    # 2 columns, automatic rows\n    with GridLayout(cols=2, gap=10) as grid:\n        Rect(50, 50, fill=Colors.LightCyan)\n        Rect(50, 50, fill=Colors.LightCyan)\n\n        # This will wrap to the next row\n        Rect(110, 50, fill=Colors.LightYellow) # Span visually if wide\n\n        Rect(50, 50, fill=Colors.LightCyan)\n\nc.fit(10).display()"
  },
  {
    "objectID": "layout.html#complex-layouts",
    "href": "layout.html#complex-layouts",
    "title": "Layouts & Composition",
    "section": "Complex Layouts",
    "text": "Complex Layouts\nFor data structures where manual positioning is impossible (like graphs or trees), Tesserax provides algorithmic layouts.\n\nHierarchical Layout (Trees & DAGs)\nThe HierarchicalLayout is designed for directed acyclic graphs and trees. It automatically calculates levels and minimizes edge crossings.\n\n\nCode\nfrom tesserax.layout import HierarchicalLayout\nfrom tesserax import Arrow\n\nwith Canvas() as c:\n    with HierarchicalLayout(orientation=\"vertical\") as tree:\n        root = Circle(20, fill=Colors.Gold)\n        l = Circle(15, fill=Colors.LightBlue)\n        r = Circle(15, fill=Colors.LightBlue)\n        ll = Circle(10, fill=Colors.LightGreen)\n        lr = Circle(10, fill=Colors.LightGreen)\n\n        tree.root(root)\n        tree.connect(root, l)\n        tree.connect(root, r)\n        tree.connect(l, ll)\n        tree.connect(l, lr)\n\n    # Define connections (Layout will position nodes, you draw edges)\n    Arrow(root.anchor(\"bottom\"), l.anchor(\"top\"))\n    Arrow(root.anchor(\"bottom\"), r.anchor(\"top\"))\n    Arrow(l.anchor(\"bottom\"), ll.anchor(\"top\"))\n    Arrow(l.anchor(\"bottom\"), lr.anchor(\"top\"))\n\nc.fit(10).display()\n\n\n\n\n\n\n\n\n\n\n\nForce-Directed Layout\nThe ForceLayout uses a physics simulation (Fruchterman-Reingold) to position nodes. This is ideal for arbitrary network graphs where structure is emergent.\nThe layout requires you to define nodes and links (edges).\n\n\nCode\nfrom tesserax.layout import ForceLayout\nfrom tesserax import Line, Shape\n\nwith Canvas() as c:\n    nodes: list[Shape] = []\n\n    # 1. Initialize Layout\n    with ForceLayout() as layout:\n        # 2. Add Nodes (they are just shapes)\n        for i in range(5):\n            n = Circle(10, fill=Colors.Orange)\n            nodes.append(n)\n            layout.add(n)\n\n        # 3. Add Constraints (links)\n        layout.connect(nodes[0], nodes[1])\n        layout.connect(nodes[1], nodes[2])\n        layout.connect(nodes[2], nodes[0]) # Triangle\n        layout.connect(nodes[2], nodes[3])\n        layout.connect(nodes[3], nodes[4])\n\n    # 5. Draw Edges based on computed positions\n    # (We draw edges *after* compute so anchors are correct)\n    Line(nodes[0].anchor(\"center\"), nodes[1].anchor(\"center\"))\n    Line(nodes[1].anchor(\"center\"), nodes[2].anchor(\"center\"))\n    Line(nodes[2].anchor(\"center\"), nodes[0].anchor(\"center\"))\n    Line(nodes[2].anchor(\"center\"), nodes[3].anchor(\"center\"))\n    Line(nodes[3].anchor(\"center\"), nodes[4].anchor(\"center\"))\n\nc.fit(10).display()"
  },
  {
    "objectID": "gallery.html",
    "href": "gallery.html",
    "title": "Gallery",
    "section": "",
    "text": "The following examples are a bit more involved and showcase the kind of drawings that can be done with Tesserax in the academic domain."
  },
  {
    "objectID": "gallery.html#sorting",
    "href": "gallery.html#sorting",
    "title": "Gallery",
    "section": "Sorting",
    "text": "Sorting\n\n\nCode\nfrom tesserax import Canvas, Square, Arrow, Group, Shape\nfrom tesserax.layout import RowLayout\n\ndef create_pointer(target_shape: Shape, label_offset=40):\n    \"\"\"Helper to create a pointer arrow below a shape.\"\"\"\n    # We use the bottom anchor of the target shape\n    base = target_shape.anchor(\"bottom\")\n    # Start the arrow lower down (dy) and point up to the shape\n    tail = base.dy(label_offset)\n    head = base.dy(5) # Stop 5px short of the shape\n    return Arrow(tail, head)\n\nwith Canvas() as canvas:\n    elements: list[Shape] = []\n\n    # 1. The Array (Memory Strip)\n    # We use a Row layout to pack squares automatically\n    with RowLayout(gap=0) as array:\n        for i in range(8):\n            # Highlight the pivot (last element) with a different style\n            is_pivot = (i == 7)\n            s = Square(\n                size=40,\n                stroke=\"red\" if is_pivot else \"black\",\n                fill=\"#ffebeb\" if is_pivot else \"white\"\n            )\n            elements.append(s)\n\n    # 2. The Pointers (i and j)\n    # We access the specific elements after the layout has settled\n    ptr_i = create_pointer(elements[2]) # Pointing to index 2\n    ptr_j = create_pointer(elements[5]) # Pointing to index 5\n\n    # 3. Pivot Label (Curved arrow from top)\n    pivot_shape = elements[-1]\n    pivot_top = pivot_shape.anchor(\"top\")\n\n    # Create a visual indicator for the pivot\n    pivot_arrow = Arrow(\n        pivot_top.d(20, -30), # Top-right offset\n        pivot_top.dy(-5)\n    )\n\ncanvas.fit(padding=20).display()"
  },
  {
    "objectID": "gallery.html#automaton",
    "href": "gallery.html#automaton",
    "title": "Gallery",
    "section": "Automaton",
    "text": "Automaton\nThis example uses a force layout to draw a simple graph that represents an automaton.\n\n\nCode\nimport math\nfrom tesserax import Canvas, Circle, Arrow\nfrom tesserax.layout import HierarchicalLayout\nfrom tesserax.core import Point\n\ndef get_boundary_point(center: Point, target: Point, radius: float) -&gt; Point:\n    \"\"\"Calculates a point on the circle's boundary facing the target.\"\"\"\n    dx = target.x - center.x\n    dy = target.y - center.y\n    dist = math.sqrt(dx*dx + dy*dy)\n    if dist == 0: return center\n\n    # Normalize and scale by radius\n    return Point(\n        center.x + (dx / dist) * radius,\n        center.y + (dy / dist) * radius\n    )\n\nwith Canvas() as canvas:\n    states: list[Shape] = []\n    radius = 20\n\n    # 1. Define the Graph Structure\n    with HierarchicalLayout(orientation=\"horizontal\") as graph:\n        # Create 5 states\n        for i in range(4):\n            states.append(Circle(r=radius))\n\n        # Connect them (Topology)\n        # q0 -&gt; q1 -&gt; q2\n        graph.connect(states[0], states[1])\n        graph.connect(states[0], states[2])\n        # q2 -&gt; q0 (cycle)\n        graph.connect(states[2], states[0])\n        # q2 -&gt; q3 -&gt; q4\n        graph.connect(states[2], states[3])\n        # Set the root\n        graph.root(states[0])\n\n    # 2. Draw Transitions (Visuals)\n    # We define edges manually to ensure directionality (ForceLayout is undirected)\n    transitions = [(0, 1), (1, 2), (2, 0), (2, 3)]\n\n    for i, j in transitions:\n        src = states[i].anchor(\"center\")\n        dst = states[j].anchor(\"center\")\n\n        # Calculate points on the boundary of the circles\n        p1 = get_boundary_point(src, dst, radius)\n        p2 = get_boundary_point(dst, src, radius)\n        Arrow(p1, p2)\n\n    # 3. Add a \"Start\" arrow pointing to q0\n    start_node = states[0].anchor(\"center\")\n    start_entry = get_boundary_point(start_node, start_node.dx(-100), radius)\n    Arrow(start_entry.dx(-40), start_entry)\n\ncanvas.fit(padding=10).display()"
  },
  {
    "objectID": "gallery.html#stack",
    "href": "gallery.html#stack",
    "title": "Gallery",
    "section": "Stack",
    "text": "Stack\nA simple illustration of a call stack.\n\n\nCode\n# examples/stack.py\nfrom tesserax import Canvas, Rect, Arrow, Group\nfrom tesserax.layout import ColumnLayout\n\nwith Canvas() as canvas:\n    with ColumnLayout(align=\"middle\", gap=2) as stack:\n        # Stack frames\n        for i in range(4):\n            # Top frame is active (different color)\n            stroke = \"blue\" if i == 0 else \"black\"\n            Rect(100, 30, stroke=stroke)\n\n    # Add a \"Stack Pointer\"\n    top_frame = stack.shapes[0]\n    sp_arrow = Arrow(\n        top_frame.anchor(\"left\").dx(-40),\n        top_frame.anchor(\"left\").dx(-5)\n    )\n\ncanvas.fit(padding=20).display()"
  },
  {
    "objectID": "gallery.html#neural-networks",
    "href": "gallery.html#neural-networks",
    "title": "Gallery",
    "section": "Neural Networks",
    "text": "Neural Networks\nThe following is a more complicated example showing how to visualize typical neural network operations like a convolution.\n\n\nCode\nfrom tesserax import Canvas, Square, Text, Arrow, Group, Shape\nfrom tesserax.layout import GridLayout, RowLayout\n\n\ndef create_matrix(rows, cols, text, data=None, highlight_region=None, cell_size=40):\n    \"\"\"\n    Creates a grid of squares with optional text and highlighting.\n    \"\"\"\n    with GridLayout(cols=cols, gap=2) as grid:\n        for r in range(rows):\n            for c in range(cols):\n                val = data[r][c] if data else 0\n\n                # Determine styling based on the highlighted region\n                is_active = False\n                if highlight_region:\n                    r_start, c_start, r_end, c_end = highlight_region\n                    if r_start &lt;= r &lt;= r_end and c_start &lt;= c &lt;= c_end:\n                        is_active = True\n\n                # Visuals\n                color = \"#e3f2fd\" if is_active else \"white\"\n                stroke = \"#1565c0\" if is_active else \"black\"\n\n                # A Group holding the box and the number\n                with Group() as cell:\n                    box = Square(cell_size, fill=color, stroke=stroke)\n                    label = Text(str(val), size=14, font=\"monospace\")\n\n                cell.align()\n\n    t = Text(text, size=16, anchor=\"middle\")\n    t.align_to(grid, anchor=\"bottom\", other_anchor=\"top\").translated(0, -10)\n\n    # Return the group with these two elements\n    return grid + t\n\n\nwith Canvas() as canvas:\n    # Data Setup (Dummy Values)\n    input_data = [[1 if i == j else 0 for j in range(5)] for i in range(5)]\n    kernel_data = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]\n    output_data = [[2, 1, 2], [1, 3, 1], [2, 1, 2]]\n\n    # We put three matrices in a row with the corresponding texts in between\n    with RowLayout(gap=20):\n        input_grid = create_matrix(\n            5, 5, \"Input (5x5)\", input_data, highlight_region=(0, 0, 2, 2)\n        )\n        math_op = Text(\"∗\", size=30)\n        kernel_grid = create_matrix(\n            3, 3, \"Kernel (3x3)\", kernel_data, highlight_region=(0, 0, 2, 2)\n        )\n        math_eq = Text(\"=\", size=30)\n        output_grid = create_matrix(\n            3, 3, \"Result (3x3)\", output_data, highlight_region=(0, 0, 0, 0)\n        )\n\ncanvas.fit(padding=40).display()"
  },
  {
    "objectID": "animations.html",
    "href": "animations.html",
    "title": "Animation & Video",
    "section": "",
    "text": "Tesserax isn’t just for static images. It includes a lightweight, code-first animation engine capable of exporting GIFs and MP4s."
  },
  {
    "objectID": "animations.html#the-scene-object",
    "href": "animations.html#the-scene-object",
    "title": "Animation & Video",
    "section": "The Scene Object",
    "text": "The Scene Object\nThe Scene is the director of your animation. It wraps a Canvas and manages the render loop, frame capture, and file export.\nAt its lowest level, you can animate simply by changing shapes in a loop and calling scene.capture(). This gives you total control over every frame.\n\n\nCode\nfrom tesserax import Canvas, Square, deg\nfrom tesserax.animation import Scene\nfrom tesserax.color import Colors\n\n# 1. Setup the static scene\nwith Canvas() as canvas:\n    rect = Square(40, fill=Colors.Orange)\n\ncanvas.fit(10)\n\n# 2. Animate\nscene = Scene(canvas, fps=30)\n\n# We manually drive the loop\nfor i in range(30):\n    rect.rotated(deg(3)) # Rotate 3 degrees per frame\n    scene.capture()      # Snap!\n\n# 3. Render\nscene.display()"
  },
  {
    "objectID": "animations.html#declarative-animations",
    "href": "animations.html#declarative-animations",
    "title": "Animation & Video",
    "section": "Declarative Animations",
    "text": "Declarative Animations\nWhile manual loops are powerful, they get messy quickly. Tesserax provides a declarative API where you define what happens, not how.\nThe Scene.play() method accepts one or more Animation objects.\n\nParallel: Arguments passed to play(a, b) run simultaneously.\nSequential: Animations added with a + b run one after another.\n\nWe use the .animate property on shapes to quickly generate these objects.\n\n\nCode\nfrom tesserax import Circle\n\nwith Canvas() as canvas:\n    box = Square(30, fill=Colors.LightBlue).translated(-40, 0)\n    ball = Circle(15, fill=Colors.Salmon).translated(40, 0)\n\ncanvas.fit(10)\nscene = Scene(canvas, fps=30)\n\n# Define animations\nmove_box = box.animate.rotate(deg(90)) | box.animate.translate(20)\nfade_ball = ball.animate.scale(0.5)\n\n# Run them together (box moves sequentially, ball scales in parallel)\nscene.play(move_box.looping(), fade_ball.looping(), duration=2.0)\n\nscene.display()\n\n\n\n\n\n\nAnimation Modifiers\nYou can tweak the timing and behavior of any animation using fluent modifiers:\n\n.reversed(): Plays backwards.\n.looping(): Plays forward then backward (yoyo).\n.repeating(n): Repeats n times within the duration.\n.delayed(t): Waits for t (0.0 to 1.0) before starting.\n.smoothed(): Applies an ease-in-out curve (default is linear).\n\n\n\nCode\nfrom tesserax import Shape\n\nwith Canvas() as c:\n    b1 = Circle(10, fill=Colors.Red).translated(-30, 0)\n    b2 = Circle(10, fill=Colors.Blue).translated(0, 0)\n    b3 = Circle(10, fill=Colors.Green).translated(30, 0)\n\nc.fit(40)\nscene = Scene(c)\n\n# Create a jump animation\ndef jump(shape: Shape):\n    return (\n        shape.animate.translate(0, -40).smoothed() |\n        shape.animate.translate(0, 0).smoothed()\n    )\n\nscene.play(\n    jump(b1),\n    jump(b2).delayed(0.2), # Start 20% later\n    jump(b3).delayed(0.4), # Start 40% later\n    duration=1.5\n)\n\nscene.display()"
  },
  {
    "objectID": "animations.html#morphing-and-warping",
    "href": "animations.html#morphing-and-warping",
    "title": "Animation & Video",
    "section": "Morphing and Warping",
    "text": "Morphing and Warping\nFor Polyline shapes, Tesserax offers advanced vertex manipulation.\n\nMorphing\nThe .morph(target) animation smoothly interpolates the points of one shape into another.\n\n\nCode\nfrom tesserax import Polyline\n\nwith Canvas() as c:\n    # Start as a Triangle\n    shape = Polyline.poly(3, 40, fill=Colors.Gold).subdivide()\n    # Target is a Hexagon\n    target = Polyline.poly(6, 40).hide()\n\nc.fit(10)\nscene = Scene(c)\n\nscene.play(\n    shape.animate.morph(target).smoothed().looping(),\n    duration=2.0\n)\n\nscene.display()\n\n\n\n\n\n\n\nWarping\nThe .warp(func) animation allows you to apply a function to every point in a shape over time. This is perfect for wave effects.\n\n\nCode\nimport math\nfrom tesserax import Point\n\nwith Canvas() as c:\n    # Create a dense line so we have points to warp\n    line = Polyline([Point(x, 0) for x in range(-50, 50, 2)], stroke=Colors.Blue)\n\nc.fit(15)\nscene = Scene(c)\n\n# Define a wave function\ndef wave(p, t):\n    # t goes 0 -&gt; 1\n    # We use it to shift the phase\n    phase = t * math.pi * 2\n    amplitude = 10\n    freq = 0.1\n    return Point(p.x, math.sin(p.x * freq + phase) * amplitude)\n\nscene.play(\n    line.animate.warp(wave).repeating(2),\n    duration=2.0\n)\n\ncanvas.fit(10)\nscene.display()"
  },
  {
    "objectID": "animations.html#text-effects",
    "href": "animations.html#text-effects",
    "title": "Animation & Video",
    "section": "Text Effects",
    "text": "Text Effects\nText objects have their own special animator with effects like write (typewriter style) and scramble (hacker style).\n\n\nCode\nfrom tesserax import Text\n\nwith Canvas() as c:\n    t1 = Text(\"Hello World\", size=24).translated(0, -20)\n    t2 = Text(\"Encryption\", size=24, fill=Colors.Green, font=\"monospace\").translated(0, 20)\n\nc.fit(10)\nscene = Scene(c)\n\nscene.play(\n    t1.animate.write(),\n    t2.animate.scramble(),\n    duration=2.0\n)\nscene.wait(1.0)\n\nscene.display()"
  },
  {
    "objectID": "animations.html#animating-arbitrary-properties",
    "href": "animations.html#animating-arbitrary-properties",
    "title": "Animation & Video",
    "section": "Animating Arbitrary Properties",
    "text": "Animating Arbitrary Properties\nSometimes you need to animate a property that Tesserax doesn’t have a built-in method for, like the radius of a circle, the gap of a layout, or a custom attribute you added to a subclass.\n\nThe property Method\nThe animator.property(name, value) method allows you to interpolate any numeric attribute on the shape from its current value to a target value.\n\n\nCode\nfrom tesserax import Circle\n\nwith Canvas() as c:\n    # A circle starts with radius 10\n    ball = Circle(10, fill=Colors.Red)\n\nc.fit(15)\nscene = Scene(c)\n\nscene.play(\n    # Explicitly animate the 'r' attribute (radius) to 50\n    ball.animate.property(\"r\", 20).looping(),\n    duration=1.0\n)\nscene.display()\n\n\n\n\n\n\n\nMagic Property Access\nFor even cleaner code, the animator supports dynamic property access. If you try to call a method on .animate that doesn’t exist (e.g., .radius(...)), Tesserax assumes you want to animate the property of that name.\n\n\nCode\nfrom tesserax import Square\n\nwith Canvas() as c:\n    # Square defined by 'size'\n    box = Square(20, fill=Colors.Blue)\n\nc.fit(25)\nscene = Scene(c)\n\nscene.play(\n    # 'size' is not a built-in animation method,\n    # so this automatically animates box.size -&gt; 100\n    box.animate.size(40).looping(),\n    duration=1.0\n)\nscene.display()"
  },
  {
    "objectID": "animations.html#custom-animation-logic",
    "href": "animations.html#custom-animation-logic",
    "title": "Animation & Video",
    "section": "Custom Animation Logic",
    "text": "Custom Animation Logic\nWhen standard interpolation isn’t enough, the .custom() method gives you a direct hook into the animation loop. You provide a callback function that receives the shape and the time (from 0 to 1), and you can do whatever you want.\nThis is perfect for complex math, interdependent properties, or non-linear behaviors. The fun part is that you add .looping() or .smoothed() or any other standard Animation modifier even to these custom animations.\n\n\nCode\nimport math\n\nwith Canvas() as c:\n    ball = Circle(10, fill=Colors.Purple)\n\nc.fit(50)\nscene = Scene(c)\n\n# A custom function to move in a spiral\ndef spiral(shape, t):\n    # t goes 0 -&gt; 1\n    angle = t * math.pi * 4  # 2 full turns\n    radius = t * 50          # Spiral out to 50px\n\n    # Update position manually\n    shape.transform.tx = math.cos(angle) * radius\n    shape.transform.ty = math.sin(angle) * radius\n\n    # We can also change other properties!\n    shape.fill = Colors.Purple.lerp(Colors.Yellow, t)\n\nscene.play(\n    ball.animate.custom(spiral).smoothed().looping(),\n    duration=3.0\n)\n\nscene.display()"
  },
  {
    "objectID": "animations.html#keyframe-animation",
    "href": "animations.html#keyframe-animation",
    "title": "Animation & Video",
    "section": "Keyframe Animation",
    "text": "Keyframe Animation\nFor complex motion graphics where an object needs to follow a specific “script” (e.g., “move right, wait, rotate, then shrink”), chaining simple animations becomes tedious.\nThe .keyframes() method allows you to define a timeline for multiple properties simultaneously in a single call.\n\nThe Timeline API\nYou pass properties as keyword arguments. Each argument accepts a dictionary mapping a normalized time (\\(0.0 \\to 1.0\\)) to a target value.\n\nIf \\(0.0\\) is missing, Tesserax infers it from the current state.\nTesserax automatically detects if the property belongs to the Shape (like fill) or its Transform (like tx, rotation).\n\n\n\nCode\nfrom tesserax.animation import ease_out, ease_in_out_cubic, linear\n\nwith Canvas() as c:\n    box = Square(30, fill=Colors.Orange)\n\nc.fit(50)\nscene = Scene(c)\n\nscene.play(\n    box.animate.keyframes(\n        # Track 1: Movement (Transform property)\n        tx={\n            0.0: -20,\n            0.4: 20, # Move fast to 100\n            0.6: 20, # Stay there for 20% of time\n            1.0: -20,    # Return home\n        },\n        # Track 2: Rotation (Transform property)\n        # We can use (value, easing) tuples for precise control\n        rotation={\n            0.0: 0,\n            1.0: (deg(360), ease_in_out_cubic) # Spin fully with smooth accel/decel\n        },\n        # Track 3: Color (Shape property)\n        fill={\n            0.5: Colors.Orange,\n            0.8: Colors.Red, # Turn red near the end\n            1.0: Colors.Orange\n        }\n    ),\n    duration=3.0\n)\n\nscene.display()\n\n\n\n\n\nBy default, Tesserax interpolates linearly between keyframes. However, you often want specific segments to feel different (e.g., a “snap” effect).\nYou can pass a tuple (value, easing_function) instead of just a raw value. The easing function applies to the time interval leading up to that keyframe."
  },
  {
    "objectID": "physics.html",
    "href": "physics.html",
    "title": "Physics-based Animations",
    "section": "",
    "text": "Tesserax includes a built-in, deterministic, baked physics engine. Unlike real-time game engines that calculate physics during the render loop, Tesserax calculates the entire simulation upfront and “bakes” it into standard KeyframeAnimation tracks.\nThis architecture offers two major advantages:"
  },
  {
    "objectID": "physics.html#the-basic",
    "href": "physics.html#the-basic",
    "title": "Physics-based Animations",
    "section": "The Basic",
    "text": "The Basic\nA high-level overview of the workflow is as follows:\n\nCreate a World.\nAdd Shape objects to the world (creates Body wrappers).\nAdd Fields (like Gravity) and global constraints.\nCall world.simulate(duration) to generate an Animation.\nPlay the animation in your Scene.\n\nHere is a complete example of a ball falling under gravity and bouncing on a static floor. First we will create the scene.\n\n\nCode\nfrom tesserax import Canvas, Circle, Rect\n\n# 1. Setup the Scene\nwith Canvas() as canvas:\n    floor = Rect(600, 50, fill=\"#333\").translated(300, 380)\n    ball = Circle(20, fill=\"#ff0055\").translated(300, 50)\n\n\nNext, we define the physical world. This involves wrapping the existing shapes that will undergo physical simulation as Bodys and place them in a World. Once set up, we bake the physics animation with world.simulate(...).\n\n\nCode\nfrom tesserax.physics import World, Gravity, Material, CircleCollider\n\nworld = World()\nworld.fields.append(Gravity())  # Downward acceleration (pixels/s^2)\nworld.add(floor, static=True)\nworld.add(\n    ball,\n    material=Material(restitution=0.8, friction=0.5),\n    collider=CircleCollider(ball.r),\n)\n\nsimulation = world.simulate(duration=3.0, dt=0.005)\n\n\nFinally, we run the animation as normal. Notice we can simulate at some fixed framerate and render at a completely different rate.\n\n\nCode\nfrom tesserax.animation import Scene\n\ncanvas.fit(10)\nscene = Scene(canvas)\nscene.play(simulation, duration=3.0)\nscene.display()"
  },
  {
    "objectID": "physics.html#constraints",
    "href": "physics.html#constraints",
    "title": "Physics-based Animations",
    "section": "Constraints",
    "text": "Constraints\nTesserax physics engine also supports some simple constraints like Springs (soft constraints) and Rods (hard constraints). These work by applying forces and corrections to bodies during simulation.\n\n\nCode\nfrom tesserax import Canvas, Rect, Circle, Line, Point\nfrom tesserax.animation import Scene\nfrom tesserax.physics import World, Gravity, Material\nfrom tesserax.physics.constraints import Spring, Rod\n\nwith Canvas() as canvas:\n    floor = Rect(600, 50, fill=\"#333\").translated(300, 380)\n    box = Rect(50, 50, fill=\"steelblue\").translated(200, 100)\n    ball = Circle(15, fill=\"orange\").translated(300, 100)\n    ball2 = Rect(20, 20, fill=\"green\").translated(400, 100)\n    spring_line = Line(\n        lambda: box.anchor(\"center\"),\n        lambda: ball.anchor(\"center\"),\n        stroke=\"gray\",\n        width=3,\n    )\n    rod_line = Line(\n        lambda: ball.anchor(\"center\"),\n        lambda: ball2.anchor(\"center\"),\n        stroke=\"gray\",\n        width=3,\n    )\n\ncanvas.fit(10)\n\nworld = World()\nworld.fields.append(Gravity())\nworld.add(floor, static=True)\n\nbody_box = world.add(box, material=Material(restitution=0.6))\nbody_box.angular_vel = 5.0  # Radians/sec\nbody_ball = world.add(\n    ball, material=Material(restitution=0.8), collider=CircleCollider(15)\n)\nbody_ball2 = world.add(\n    ball2, material=Material(restitution=0.1), mass=2\n)\n\n# Physics Constraint\nworld.constraint(Spring(body_box, body_ball, length=100, k=5.0))\nworld.constraint(Rod(body_ball, body_ball2, length=100))\n\n# 3. Bake\nsimulation = world.simulate(duration=4.0)\n\n# 4. Play\nscene = Scene(canvas)\nscene.play(simulation, duration=4.0)\nscene.display()"
  },
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "Core Concepts & Primitives",
    "section": "",
    "text": "Tesserax is designed to be a “thin layer” of geometric logic over SVG. Unlike plotting libraries that try to decide for you how axes and scales should work, Tesserax gives you a blank canvas and a set of precise drafting tools.\nThis guide covers the fundamental building blocks: the coordinate system, basic shapes, transformations, the anchor system, and the powerful Polyline API."
  },
  {
    "objectID": "core.html#the-canvas-and-coordinates",
    "href": "core.html#the-canvas-and-coordinates",
    "title": "Core Concepts & Primitives",
    "section": "The Canvas and Coordinates",
    "text": "The Canvas and Coordinates\nEvery diagram begins with a Canvas. In Tesserax, the Canvas serves two roles:\n\nContainer: It collects all shapes created within its context.\nViewport: It manages the final SVG bounding box and coordinate mapping.\n\n\nMathematical Coordinate System\nTesserax follows the standard SVG Coordinate System:\n\nThe origin \\((0, 0)\\) is at the top-left corner (initially).\nThe X-axis points to the right (\\(+x\\)).\nThe Y-axis points down (\\(+y\\)).\n\nThis is crucial to remember when applying rotations. A positive rotation (counter-clockwise) moves the \\(+x\\) axis towards the \\(+y\\) axis (downwards on the screen).\n\n\nCode\nfrom tesserax import Canvas, Rect, Text\nfrom tesserax.color import Colors\n\nwith Canvas() as canvas:\n    # A simple reference grid\n    Rect(100, 100, stroke=Colors.LightGray, fill=Colors.White)\n\n    # Origin marker\n    Text(\"(0,0)\", size=20)\n\n    # Positive X/Y indication\n    Text(\"+X\", size=20).translated(70, 0)\n    Text(\"+Y\", size=20).translated(0, 70)\n\ncanvas.fit(5).display()"
  },
  {
    "objectID": "core.html#basic-primitives",
    "href": "core.html#basic-primitives",
    "title": "Core Concepts & Primitives",
    "section": "Basic Primitives",
    "text": "Basic Primitives\nTesserax provides a suite of geometric atoms. All visual shapes inherit from the Visual class, which standardizes properties like fill, stroke, and width.\n\nRectangles and Circles\n\nRect(w, h): Defined by width and height. Centered at by default.\nSquare(size): A convenience wrapper for Rect.\nCircle(r): Defined by radius. Centered at .\nEllipse(rx, ry): Defined by horizontal and vertical radii.\n\n\n\nCode\nfrom tesserax import Canvas, Rect, Square, Circle, Ellipse\n\nwith Canvas() as c:\n    # Shapes are placed at (0,0) by default, so we translate them to separate them.\n    Square(40, fill=Colors.LightBlue).translated(0, 0)\n    Rect(60, 30, fill=Colors.LightGreen).translated(60, 0)\n    Circle(20, fill=Colors.Salmon).translated(120, 0)\n    Ellipse(20, 10, fill=Colors.Plum).translated(170, 0)\n\nc.fit(10).display()\n\n\n\n\n\n\n\n\n\n\n\nText and Alignment\nText in SVG can be tricky due to alignment issues. Tesserax simplifies this by defaulting to center/middle alignment.\nYou can control this via:\n\nanchor: Horizontal alignment (\"start\", \"middle\", \"end\").\nbaseline: Vertical alignment (\"top\", \"middle\", \"bottom\").\n\n\n\nCode\nfrom tesserax import Text, Line, Point\n\nwith Canvas() as c:\n    # Draw a crosshair at the origin to show alignment\n    Line(Point(0, -20), Point(0, 20), stroke=Colors.LightGray)\n    Line(Point(-50, 0), Point(50, 0), stroke=Colors.LightGray)\n\n    # Default Text (Centered)\n    Text(\"Origin\", size=16, fill=Colors.Black)\n\n    # Custom alignment\n    Text(\"Top-Left\", anchor=\"end\", baseline=\"bottom\").translated(-20, -20)\n    Text(\"Bottom-Right\", anchor=\"start\", baseline=\"top\").translated(20, 20)\n\nc.fit(10).display()"
  },
  {
    "objectID": "core.html#the-transformation-model",
    "href": "core.html#the-transformation-model",
    "title": "Core Concepts & Primitives",
    "section": "The Transformation Model",
    "text": "The Transformation Model\nEvery shape in Tesserax carries a Transform object. This defines an Affine Transformation that maps the shape’s local coordinate space to the parent space.\nThe operation order is strict: Scale - Rotate - Translate.\n\nScale: The object is stretched.\nRotate: The object is rotated around the (scaled) origin.\nTranslate: The object is moved to its final position.\n\nTesserax provides a fluent API to chain these operations:\n\n\nCode\nfrom tesserax import Canvas, Rect, deg\n\nwith Canvas() as c:\n    # 1. Create a rectangle at (0,0)\n    r = Rect(50, 30, fill=Colors.LightBlue, stroke=Colors.Blue)\n\n    # 2. Scale it by 1.5x\n    # 3. Rotate it by 45 degrees\n    # 4. Move it to (50, 50)\n    r.scaled(1.5).rotated(deg(45)).translated(50, 50)\n\n    # Show the origin for reference\n    Circle(2, fill=Colors.Red).translated(50, 50)\n\nc.fit(20).display()"
  },
  {
    "objectID": "core.html#the-anchor-system",
    "href": "core.html#the-anchor-system",
    "title": "Core Concepts & Primitives",
    "section": "The Anchor System",
    "text": "The Anchor System\nOne of Tesserax’s most powerful features is semantic anchoring. Because shapes are often nested inside Groups or transformed heavily, calculating the exact coordinate of “the top-right corner of that rotated rectangle” is mathematically tedious.\nThe .anchor(name) method solves this by resolving the local coordinate through the entire transformation stack.\nAvailable anchors: center, top, bottom, left, right, topleft, topright, bottomleft, bottomright.\n\n\nCode\nfrom tesserax import Arrow\n\nwith Canvas() as c:\n    # A generic shape\n    obj = Rect(60, 40, fill=Colors.Honeydew, stroke=Colors.Green)\n    obj.rotated(deg(30)).translated(50, 50)\n\n    # A target point\n    target = Circle(5, fill=Colors.Red).translated(150, 50)\n\n    # Connect the top-right corner of the rotated rect to the target\n    # We don't need to know where \"top-right\" is in global space,\n    # .anchor() calculates it.\n    Arrow(obj.anchor(\"topright\"), target.anchor(\"center\"))\n\nc.fit(20).display()"
  },
  {
    "objectID": "core.html#paths-and-lines",
    "href": "core.html#paths-and-lines",
    "title": "Core Concepts & Primitives",
    "section": "Paths and Lines",
    "text": "Paths and Lines\nFor arbitrary drawing, Tesserax offers both low-level and high-level path tools.\n\nThe Low-Level Path\nThe Path class maps directly to SVG commands (M, L, C, Q, Z).\n\n\nCode\nfrom tesserax import Path\n\nwith Canvas() as c:\n    p = Path(fill=Colors.Transparent, stroke=Colors.Blue, width=2)\n    p.jump_to(0, 0)\n    p.line_to(50, 50)\n    p.quadratic_to(100, 50, 100, 0) # Control point (100,50), End (100,0)\n\nc.fit(10).display()\n\n\n\n\n\n\n\n\n\n\n\nLines and Arrows\nLine and Arrow are specialized paths that connect two points. They support a curvature parameter to create arcs without manually calculating Bezier control points.\n\n\nCode\nfrom tesserax import Line\n\nwith Canvas() as c:\n    start, end = Point(0, 0), Point(100, 0)\n\n    Line(start, end, curvature=0, stroke=Colors.LightGray) # Straight\n    Line(start, end, curvature=0.5, stroke=Colors.Blue)   # Arc Up\n    Arrow(start, end, curvature=-0.5, stroke=Colors.Red)  # Arc Down\n\nc.fit(30).display()"
  },
  {
    "objectID": "core.html#the-polyline-api",
    "href": "core.html#the-polyline-api",
    "title": "Core Concepts & Primitives",
    "section": "The Polyline API",
    "text": "The Polyline API\nThe Polyline is a versatile tool for creating complex polygons, wireframes, and smooth curves. It maintains a list of Point objects and renders them sequentially.\n\nSmoothing and Rounding\nThe smoothness parameter (\\(0\\) to \\(1\\)) automatically converts sharp vertices into rounded corners using quadratic Bezier interpolation.\n\n\nCode\nfrom tesserax import Polyline\n\npts = [Point(0, 0), Point(50, 50), Point(100, 0), Point(150, 50)]\n\nwith Canvas() as c:\n    # Sharp (0.0)\n    Polyline(pts, smoothness=0, stroke=Colors.Black).translated(0, 0)\n\n    # Rounded (0.5)\n    Polyline(pts, smoothness=0.5, stroke=Colors.Blue).translated(0, 60)\n\n    # Fluid (1.0)\n    Polyline(pts, smoothness=1.0, stroke=Colors.Red).translated(0, 120)\n\nc.fit(10).display()\n\n\n\n\n\n\n\n\n\n\n\nProcedural Generation\nThe Polyline class includes powerful methods to procedurally generate and manipulate shapes.\n\nPolyline.poly(n, radius): Creates a regular n-gon (triangle, hexagon, etc.).\n.subdivide(n): Inserts midpoints between every segment, increasing resolution.\n.simplify(tolerance): Removes points that are collinear or redundant.\n.expand(delta): Pushes points away from the origin (inflation).\n.apply(func): Maps a function over every point.\n\n\n\nCode\nimport math\n\nwith Canvas() as c:\n    # 1. Create a Hexagon\n    hex = Polyline.poly(n=6, radius=40, fill=Colors.AliceBlue)\n    hex.translated(50, 50)\n\n    # 2. Create a \"Wobbly\" Circle\n    # Start with a simple polygon, subdivide it to get many vertices,\n    # then apply a noise function to the radius.\n    blob = Polyline.poly(n=8, radius=40, fill=Colors.MistyRose, smoothness=1)\n    blob.subdivide(3) # Increase vertex count 8 -&gt; 16 -&gt; 32 -&gt; 64\n\n    # Apply a wave function to distort it\n    def distort(p: Point) -&gt; Point:\n        # Get angle of point\n        theta = math.atan2(p.y, p.x)\n        # Vary radius based on angle\n        wave = math.sin(theta * 5) * 5\n        return p + p.normalize() * wave\n\n    blob.apply(distort).simplify(0.1)\n    blob.translated(150, 50)\n\n    # 3. Contract/Expand\n    # Useful for creating outlines or offsets\n    base = Polyline.poly(4, 30, stroke=Colors.Black)\n    inner = base.clone().contract(5) # Shrink\n\n    base.translated(250, 50)\n    inner.translated(250, 50)\n\nc.fit(10).display()"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Tesserax: A Lightweight SVG Rendering Library",
    "section": "",
    "text": "Tesserax is a modern Python 3.12 library designed for programmatic SVG generation with a focus on ease of use, layout management, and flexible geometric primitives. It is particularly well-suited for visualizing data structures, algorithms, and technical diagrams.\nBeyond static diagrams, Tesserax now includes a deterministic physics engine and a cinematic animation system, making it a complete toolkit for scientific communication."
  },
  {
    "objectID": "index.html#key-features",
    "href": "index.html#key-features",
    "title": "Tesserax: A Lightweight SVG Rendering Library",
    "section": "Key Features",
    "text": "Key Features\n\nRich Primitives: Includes standard shapes (Rect, Circle) plus advanced procedural geometry like Polyline with smoothing and subdivision support.\nDeclarative Layouts: Effortlessly arrange shapes in Row, Column, or Grid containers, or use algorithmic layouts like Tree and Force.\nSmart Canvas: Automatically fit the canvas viewport to the content with adjustable padding.\nAnchor System: Connect shapes using semantic anchors like top, bottom, left, right, and center.\nCinematic Animations: Create complex motion graphics using a declarative, code-first API that supports keyframes, morphing, and warping.\nPhysics Simulation: Bake high-precision rigid body simulations directly into your animations using the built-in World and Body primitives."
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "Tesserax: A Lightweight SVG Rendering Library",
    "section": "Installation",
    "text": "Installation\nTesserax has zero dependencies (literally). It’s 100% pure Python, and can be easily installed with pip:\npip install tesserax\nOr if you’re one of the cool kids, using uv:\nuv add tesserax\nIf you want support for saving PNG files, install with the export extra:\npip install tesserax[export]"
  },
  {
    "objectID": "index.html#quick-start",
    "href": "index.html#quick-start",
    "title": "Tesserax: A Lightweight SVG Rendering Library",
    "section": "Quick Start",
    "text": "Quick Start\nTo showcase how Tesserax works, we’ll build a small illustration step by step. We will start with a blank canvas and gradually add layers of complexity, from simple text to automated layouts and animations.\n\nStep 1: The Canvas and Text\nFirst, we initialize the Canvas and add the central Text element. The Canvas acts as our root container.\n\n\nCode\nfrom tesserax import Canvas, Text\nfrom tesserax.color import Colors\n\nwith Canvas() as canvas:\n    t = Text(\n        \"tesserax\",\n        size=48,\n        font=\"sans-serif\",\n        fill=Colors.Navy,\n        anchor=\"middle\",\n    )\n\ncanvas.fit().display()\n\n\n\n\n\n\n\n\n\n\n\nStep 2: Adding Geometric Shapes\nNext, we add a Square and a Circle. At this stage, we create them without specific coordinates.\n\n\nCode\nfrom tesserax import Square, Circle\nfrom tesserax.color import Colors\n\nwith canvas:\n    r = Square(30, fill=Colors.Green, stroke=Colors.Transparent).translated(-120, 0)\n    c = Circle(20, fill=Colors.Red, stroke=Colors.Transparent).translated(120, 0)\n\ncanvas.fit().display()\n\n\n\n\n\n\n\n\n\n\n\nStep 3: Distribution with Groups\nWe can arrange these elements more easily with a Group. Groups can reorganize their inner shapes with align and distribute.\n\n\nCode\nfrom tesserax import Group\n\nwith Canvas() as canvas:\n    with Group() as g:\n        r = Square(30, fill=Colors.Green, stroke=Colors.Transparent)\n        t = Text(\n            \"tesserax\",\n            size=48,\n            font=\"sans-serif\",\n            fill=Colors.Navy,\n            anchor=\"middle\",\n        )\n        c = Circle(20, fill=Colors.Red, stroke=Colors.Transparent)\n\n    g.align(\"horizontal\").distribute(\"horizontal\")\n\ncanvas.fit(10).display()\n\n\n\n\n\n\n\n\n\n\n\nStep 3a: Using Layouts\nAn alternative is to use Layout subclasses like RowLayout, which automates this logic.\n\n\nCode\nfrom tesserax.layout import RowLayout\n\nwith Canvas() as canvas:\n    with RowLayout() as logo:\n        r = Square(30, fill=Colors.Green, stroke=Colors.Transparent)\n        t = Text(\n            \"tesserax\",\n            size=48,\n            font=\"sans-serif\",\n            fill=Colors.Navy,\n            anchor=\"middle\",\n        )\n        c = Circle(20, fill=Colors.Red, stroke=Colors.Transparent)\n\ncanvas.fit().display()\n\n\n\n\n\n\n\n\n\n\n\nStep 4: Adding the Underline\nWe use the semantic anchor system to draw a Polyline connecting the shapes.\n\n\nCode\nfrom tesserax import Polyline\n\nwith canvas:\n    p = Polyline(\n        points=[r.anchor(\"bottom\").dy(10), c.anchor(\"bottom\").dy(10)],\n        smoothness=1.0,\n        stroke=Colors.Black,\n        marker_end=\"arrow\"\n    )\n\ncanvas.fit(5).display()\n\n\n\n\n\n\n\n\n\n\n\nStep 5: Making a Squiggly Line\nWe can use subdivide and apply on the Polyline to creating a procedurally generated curve.\n\n\nCode\nimport math\n\np.subdivide(7).apply(\n    lambda p: p.dy(math.sin((p.x / logo.bounds().width * 20 + 5)) * 5)\n)\n\ncanvas.fit(10).display()\n\n\n\n\n\n\n\n\n\n\n\nStep 6: Animating the Logo\nFinally, we use a Scene to animate the logo using the declarative fluent API.\n\n\nCode\nfrom tesserax.animation import Scene\nfrom tesserax import deg\n\nscene = Scene(canvas)\nscene.play(\n    r.animate.rotate(deg(90)),\n    c.animate.translate(-10, 0) | c.animate.translate(0, 0),\n    p.animate.warp(\n        lambda p, t: p.dy(\n            math.sin(p.x / logo.bounds().width * 20 + t * math.pi * 2) * 5\n        )\n    ),\n    duration=1,\n)\n\nscene.display()"
  },
  {
    "objectID": "index.html#deep-dive-beyond-the-basics",
    "href": "index.html#deep-dive-beyond-the-basics",
    "title": "Tesserax: A Lightweight SVG Rendering Library",
    "section": "Deep Dive: Beyond the Basics",
    "text": "Deep Dive: Beyond the Basics\nTesserax scales from simple scripts to complex simulations. Here is an overview of the advanced capabilities available.\n\nGeometric Primitives & Procedural Shapes\nTesserax provides a robust suite of atoms like Rect, Circle, Ellipse, and Arrow.\n\nPolyline API: The Polyline class supports smoothing (Bezier interpolation), subdivision (increasing resolution), and simplification (reducing vertices).\nPath API: For low-level control, use the Path class with standard SVG commands (move_to, cubic_to, arc).\n\n\n\nThe Layout Engine\nForget manual pixel pushing. Tesserax offers a hierarchy of layout engines:\n\nStandard Layouts: Row, Column, and Grid automatically position elements based on gaps and alignment.\nHierarchical Layout: Automatically draws Trees and Directed Acyclic Graphs (DAGs).\nForce-Directed Layout: Simulates physical forces to arrange arbitrary network graphs.\n\n\n\nCinematic Animation\nThe animation system is designed for storytelling, not just movement.\n\nDeclarative API: Compose animations using parallel (|) and sequential (+) operators.\nKeyframes: Define complex multi-stage timelines for any property (position, rotation, color).\nMorphing & Warping: Smoothly transform one shape into another or apply wave functions to geometry.\n\n\n\nPhysics Engine\nTesserax includes a baked physics engine for high-precision rigid body simulations.\n\nDeterministic: Define a World, add Body objects, and apply Fields like Gravity or Drag.\nBaked Playback: The simulation is calculated upfront and converted into standard keyframes, allowing high-resolution physics (e.g., 1000 steps/sec) to play back smoothly at any framerate.\nInteroperable: Physics animations can be mixed and matched with standard tweens."
  },
  {
    "objectID": "index.html#why-tesserax",
    "href": "index.html#why-tesserax",
    "title": "Tesserax: A Lightweight SVG Rendering Library",
    "section": "Why Tesserax?",
    "text": "Why Tesserax?\nIn the Python ecosystem, there is a clear divide between data visualization (plotting numbers) and diagrammatic representation (drawing concepts).\nTesserax is for Scientific Drawing—providing the low-level primitives needed for total layout authority.\nLibraries like Matplotlib map data to charts. Tesserax maps concepts to geometry. Use Tesserax for the schematics, geometric proofs, and algorithmic walkthroughs in your papers.\nTikZ is the industry standard for academic figures but uses a cryptic macro language. Tesserax brings that same “total-control” philosophy to Python 3.12, giving you coordinate-invariant precision with the power of Python’s loops and types."
  },
  {
    "objectID": "index.html#contribution",
    "href": "index.html#contribution",
    "title": "Tesserax: A Lightweight SVG Rendering Library",
    "section": "Contribution",
    "text": "Contribution\nTesserax is free as in both free beer and free speech. License is MIT.\nContributions are always welcomed! Fork, clone, and submit a pull request."
  }
]