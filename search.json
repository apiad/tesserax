[
  {
    "objectID": "layout.html",
    "href": "layout.html",
    "title": "Layouts & Composition",
    "section": "",
    "text": "While you can position every shape manually using .translated(x, y), Tesserax shines when you let it handle the geometry for you. The layout system is built on a hierarchy of abstractions, starting from simple groups and moving up to force-directed graph algorithms."
  },
  {
    "objectID": "layout.html#grouping-objects",
    "href": "layout.html#grouping-objects",
    "title": "Layouts & Composition",
    "section": "Grouping Objects",
    "text": "Grouping Objects\nThe Group class is the fundamental unit of composition. It treats a collection of shapes as a single object, allowing you to transform them together.\n\nThe Context Manager Pattern\nThe most idiomatic way to create a group is with the with statement.\n\n\nCode\nfrom tesserax import Canvas, Group, Rect, Circle, Text\nfrom tesserax.color import Colors\n\nwith Canvas() as c:\n    # A group acts as a local container\n    with Group() as g:\n        Rect(100, 100, fill=Colors.LightBlue)\n        Text(\"Group 1\")\n\n    # You can transform the entire group at once\n    g.translated(50, 50)\n\n    with Group() as g2:\n        Circle(30, fill=Colors.Salmon)\n\n    g2.translated(150, 50)\n\nc.fit(10).display()"
  },
  {
    "objectID": "layout.html#manual-layouts-align-and-distribute",
    "href": "layout.html#manual-layouts-align-and-distribute",
    "title": "Layouts & Composition",
    "section": "Manual Layouts: Align and Distribute",
    "text": "Manual Layouts: Align and Distribute\nBefore reaching for a full layout engine, you can often get what you need using the procedural API on Group.\n\n.align(axis, anchor): Aligns all children along an axis relative to the first child.\n.distribute(axis, gap, mode): Spaces children out evenly.\n\n\n\nCode\nfrom tesserax import Square\n\nwith Canvas() as c:\n    with Group() as g:\n        Square(20, fill=Colors.Red)\n        Square(30, fill=Colors.Green)\n        Square(40, fill=Colors.Blue)\n\n    # 1. Align centers vertically\n    g.align(\"vertical\", anchor=\"center\")\n\n    # 2. Distribute horizontally with 10px gap\n    g.distribute(\"horizontal\", gap=10)\n\n    g.translated(50, 50)\n\nc.fit(10).display()"
  },
  {
    "objectID": "layout.html#standard-layouts",
    "href": "layout.html#standard-layouts",
    "title": "Layouts & Composition",
    "section": "Standard Layouts",
    "text": "Standard Layouts\nStandard layouts like Row and Column are specialized Groups that automatically apply alignment and distribution logic when they are closed.\n\nRow and Column\nThese layouts are perfect for linear arrangements. They can be nested arbitrarily.\n\n\nCode\nfrom tesserax.layout import RowLayout, ColumnLayout\n\nwith Canvas() as c:\n    # A Row automatically distributes horizontally\n    with RowLayout(gap=10, align=\"middle\") as row:\n        Rect(20, 40, fill=Colors.LightGray)\n        Circle(15, fill=Colors.MistyRose)\n        Rect(20, 20, fill=Colors.LightCoral)\n\n        # A Column automatically distributes vertically\n        # Notice we can nest layouts\n        with ColumnLayout(gap=10, align=\"middle\") as col:\n            Rect(40, 20, fill=Colors.PowderBlue)\n            Circle(15, fill=Colors.Thistle)\n\nc.fit(10).display()\n\n\n\n\n\n\n\n\n\n\n\nThe Grid Layout\nThe Grid layout provides a powerful 2D arrangement system. Unlike a simple HTML table, the Tesserax Grid allows for spanning and alignment control per cell.\n\n\nCode\nfrom tesserax.layout import GridLayout\n\nwith Canvas() as c:\n    # 2 columns, automatic rows\n    with GridLayout(cols=2, gap=10) as grid:\n        Rect(50, 50, fill=Colors.LightCyan)\n        Rect(50, 50, fill=Colors.LightCyan)\n\n        # This will wrap to the next row\n        Rect(110, 50, fill=Colors.LightYellow) # Span visually if wide\n\n        Rect(50, 50, fill=Colors.LightCyan)\n\nc.fit(10).display()"
  },
  {
    "objectID": "layout.html#complex-layouts",
    "href": "layout.html#complex-layouts",
    "title": "Layouts & Composition",
    "section": "Complex Layouts",
    "text": "Complex Layouts\nFor data structures where manual positioning is impossible (like graphs or trees), Tesserax provides algorithmic layouts.\n\nHierarchical Layout (Trees & DAGs)\nThe HierarchicalLayout is designed for directed acyclic graphs and trees. It automatically calculates levels and minimizes edge crossings.\n\n\nCode\nfrom tesserax.layout import HierarchicalLayout\nfrom tesserax import Arrow\n\nwith Canvas() as c:\n    with HierarchicalLayout(orientation=\"vertical\") as tree:\n        root = Circle(20, fill=Colors.Gold)\n        l = Circle(15, fill=Colors.LightBlue)\n        r = Circle(15, fill=Colors.LightBlue)\n        ll = Circle(10, fill=Colors.LightGreen)\n        lr = Circle(10, fill=Colors.LightGreen)\n\n        tree.root(root)\n        tree.connect(root, l)\n        tree.connect(root, r)\n        tree.connect(l, ll)\n        tree.connect(l, lr)\n\n    # Define connections (Layout will position nodes, you draw edges)\n    Arrow(root.anchor(\"bottom\"), l.anchor(\"top\"))\n    Arrow(root.anchor(\"bottom\"), r.anchor(\"top\"))\n    Arrow(l.anchor(\"bottom\"), ll.anchor(\"top\"))\n    Arrow(l.anchor(\"bottom\"), lr.anchor(\"top\"))\n\nc.fit(10).display()\n\n\n\n\n\n\n\n\n\n\n\nForce-Directed Layout\nThe ForceLayout uses a physics simulation (Fruchterman-Reingold) to position nodes. This is ideal for arbitrary network graphs where structure is emergent.\nThe layout requires you to define nodes and links (edges).\n\n\nCode\nfrom tesserax.layout import ForceLayout\nfrom tesserax import Line, Shape\n\nwith Canvas() as c:\n    nodes: list[Shape] = []\n\n    # 1. Initialize Layout\n    with ForceLayout() as layout:\n        # 2. Add Nodes (they are just shapes)\n        for i in range(5):\n            n = Circle(10, fill=Colors.Orange)\n            nodes.append(n)\n            layout.add(n)\n\n        # 3. Add Constraints (links)\n        layout.connect(nodes[0], nodes[1])\n        layout.connect(nodes[1], nodes[2])\n        layout.connect(nodes[2], nodes[0]) # Triangle\n        layout.connect(nodes[2], nodes[3])\n        layout.connect(nodes[3], nodes[4])\n\n    # 5. Draw Edges based on computed positions\n    # (We draw edges *after* compute so anchors are correct)\n    Line(nodes[0].anchor(\"center\"), nodes[1].anchor(\"center\"))\n    Line(nodes[1].anchor(\"center\"), nodes[2].anchor(\"center\"))\n    Line(nodes[2].anchor(\"center\"), nodes[0].anchor(\"center\"))\n    Line(nodes[2].anchor(\"center\"), nodes[3].anchor(\"center\"))\n    Line(nodes[3].anchor(\"center\"), nodes[4].anchor(\"center\"))\n\nc.fit(10).display()"
  },
  {
    "objectID": "gallery.html",
    "href": "gallery.html",
    "title": "Gallery",
    "section": "",
    "text": "The following examples are a bit more involved and showcase the kind of drawings that can be done with Tesserax in the academic domain."
  },
  {
    "objectID": "gallery.html#sorting",
    "href": "gallery.html#sorting",
    "title": "Gallery",
    "section": "Sorting",
    "text": "Sorting\n\n\nCode\nfrom tesserax import Canvas, Square, Arrow, Group, Shape\nfrom tesserax.layout import RowLayout\n\ndef create_pointer(target_shape: Shape, label_offset=40):\n    \"\"\"Helper to create a pointer arrow below a shape.\"\"\"\n    # We use the bottom anchor of the target shape\n    base = target_shape.anchor(\"bottom\")\n    # Start the arrow lower down (dy) and point up to the shape\n    tail = base.dy(label_offset)\n    head = base.dy(5) # Stop 5px short of the shape\n    return Arrow(tail, head)\n\nwith Canvas() as canvas:\n    elements: list[Shape] = []\n\n    # 1. The Array (Memory Strip)\n    # We use a Row layout to pack squares automatically\n    with RowLayout(gap=0) as array:\n        for i in range(8):\n            # Highlight the pivot (last element) with a different style\n            is_pivot = (i == 7)\n            s = Square(\n                size=40,\n                stroke=\"red\" if is_pivot else \"black\",\n                fill=\"#ffebeb\" if is_pivot else \"white\"\n            )\n            elements.append(s)\n\n    # 2. The Pointers (i and j)\n    # We access the specific elements after the layout has settled\n    ptr_i = create_pointer(elements[2]) # Pointing to index 2\n    ptr_j = create_pointer(elements[5]) # Pointing to index 5\n\n    # 3. Pivot Label (Curved arrow from top)\n    pivot_shape = elements[-1]\n    pivot_top = pivot_shape.anchor(\"top\")\n\n    # Create a visual indicator for the pivot\n    pivot_arrow = Arrow(\n        pivot_top.d(20, -30), # Top-right offset\n        pivot_top.dy(-5)\n    )\n\ncanvas.fit(padding=20).display()"
  },
  {
    "objectID": "gallery.html#automaton",
    "href": "gallery.html#automaton",
    "title": "Gallery",
    "section": "Automaton",
    "text": "Automaton\nThis example uses a force layout to draw a simple graph that represents an automaton.\n\n\nCode\nimport math\nfrom tesserax import Canvas, Circle, Arrow\nfrom tesserax.layout import HierarchicalLayout\nfrom tesserax.core import Point\n\ndef get_boundary_point(center: Point, target: Point, radius: float) -&gt; Point:\n    \"\"\"Calculates a point on the circle's boundary facing the target.\"\"\"\n    dx = target.x - center.x\n    dy = target.y - center.y\n    dist = math.sqrt(dx*dx + dy*dy)\n    if dist == 0: return center\n\n    # Normalize and scale by radius\n    return Point(\n        center.x + (dx / dist) * radius,\n        center.y + (dy / dist) * radius\n    )\n\nwith Canvas() as canvas:\n    states: list[Shape] = []\n    radius = 20\n\n    # 1. Define the Graph Structure\n    with HierarchicalLayout(orientation=\"horizontal\") as graph:\n        # Create 5 states\n        for i in range(4):\n            states.append(Circle(r=radius))\n\n        # Connect them (Topology)\n        # q0 -&gt; q1 -&gt; q2\n        graph.connect(states[0], states[1])\n        graph.connect(states[0], states[2])\n        # q2 -&gt; q0 (cycle)\n        graph.connect(states[2], states[0])\n        # q2 -&gt; q3 -&gt; q4\n        graph.connect(states[2], states[3])\n        # Set the root\n        graph.root(states[0])\n\n    # 2. Draw Transitions (Visuals)\n    # We define edges manually to ensure directionality (ForceLayout is undirected)\n    transitions = [(0, 1), (1, 2), (2, 0), (2, 3)]\n\n    for i, j in transitions:\n        src = states[i].anchor(\"center\")\n        dst = states[j].anchor(\"center\")\n\n        # Calculate points on the boundary of the circles\n        p1 = get_boundary_point(src, dst, radius)\n        p2 = get_boundary_point(dst, src, radius)\n        Arrow(p1, p2)\n\n    # 3. Add a \"Start\" arrow pointing to q0\n    start_node = states[0].anchor(\"center\")\n    start_entry = get_boundary_point(start_node, start_node.dx(-100), radius)\n    Arrow(start_entry.dx(-40), start_entry)\n\ncanvas.fit(padding=10).display()"
  },
  {
    "objectID": "gallery.html#stack",
    "href": "gallery.html#stack",
    "title": "Gallery",
    "section": "Stack",
    "text": "Stack\nA simple illustration of a call stack.\n\n\nCode\n# examples/stack.py\nfrom tesserax import Canvas, Rect, Arrow, Group\nfrom tesserax.layout import ColumnLayout\n\nwith Canvas() as canvas:\n    with ColumnLayout(align=\"middle\", gap=2) as stack:\n        # Stack frames\n        for i in range(4):\n            # Top frame is active (different color)\n            stroke = \"blue\" if i == 0 else \"black\"\n            Rect(100, 30, stroke=stroke)\n\n    # Add a \"Stack Pointer\"\n    top_frame = stack.shapes[0]\n    sp_arrow = Arrow(\n        top_frame.anchor(\"left\").dx(-40),\n        top_frame.anchor(\"left\").dx(-5)\n    )\n\ncanvas.fit(padding=20).display()"
  },
  {
    "objectID": "gallery.html#neural-networks",
    "href": "gallery.html#neural-networks",
    "title": "Gallery",
    "section": "Neural Networks",
    "text": "Neural Networks\nThe following is a more complicated example showing how to visualize typical neural network operations like a convolution.\n\n\nCode\nfrom tesserax import Canvas, Square, Text, Arrow, Group, Shape\nfrom tesserax.layout import GridLayout, RowLayout\n\n\ndef create_matrix(rows, cols, text, data=None, highlight_region=None, cell_size=40):\n    \"\"\"\n    Creates a grid of squares with optional text and highlighting.\n    \"\"\"\n    with GridLayout(cols=cols, gap=2) as grid:\n        for r in range(rows):\n            for c in range(cols):\n                val = data[r][c] if data else 0\n\n                # Determine styling based on the highlighted region\n                is_active = False\n                if highlight_region:\n                    r_start, c_start, r_end, c_end = highlight_region\n                    if r_start &lt;= r &lt;= r_end and c_start &lt;= c &lt;= c_end:\n                        is_active = True\n\n                # Visuals\n                color = \"#e3f2fd\" if is_active else \"white\"\n                stroke = \"#1565c0\" if is_active else \"black\"\n\n                # A Group holding the box and the number\n                with Group() as cell:\n                    box = Square(cell_size, fill=color, stroke=stroke)\n                    label = Text(str(val), size=14, font=\"monospace\")\n\n                cell.align()\n\n    t = Text(text, size=16, anchor=\"middle\")\n    t.align_to(grid, anchor=\"bottom\", other_anchor=\"top\").translated(0, -10)\n\n    # Return the group with these two elements\n    return grid + t\n\n\nwith Canvas() as canvas:\n    # Data Setup (Dummy Values)\n    input_data = [[1 if i == j else 0 for j in range(5)] for i in range(5)]\n    kernel_data = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]\n    output_data = [[2, 1, 2], [1, 3, 1], [2, 1, 2]]\n\n    # We put three matrices in a row with the corresponding texts in between\n    with RowLayout(gap=20):\n        input_grid = create_matrix(\n            5, 5, \"Input (5x5)\", input_data, highlight_region=(0, 0, 2, 2)\n        )\n        math_op = Text(\"∗\", size=30)\n        kernel_grid = create_matrix(\n            3, 3, \"Kernel (3x3)\", kernel_data, highlight_region=(0, 0, 2, 2)\n        )\n        math_eq = Text(\"=\", size=30)\n        output_grid = create_matrix(\n            3, 3, \"Result (3x3)\", output_data, highlight_region=(0, 0, 0, 0)\n        )\n\ncanvas.fit(padding=40).display()"
  },
  {
    "objectID": "animations.html",
    "href": "animations.html",
    "title": "Animation & Video",
    "section": "",
    "text": "Tesserax isn’t just for static images. It includes a lightweight, code-first animation engine capable of exporting GIFs and MP4s."
  },
  {
    "objectID": "animations.html#the-scene-object",
    "href": "animations.html#the-scene-object",
    "title": "Animation & Video",
    "section": "The Scene Object",
    "text": "The Scene Object\nThe Scene is the director of your animation. It wraps a Canvas and manages the render loop, frame capture, and file export.\nAt its lowest level, you can animate simply by changing shapes in a loop and calling scene.capture(). This gives you total control over every frame.\n\n\nCode\nfrom tesserax import Canvas, Square, deg\nfrom tesserax.animation import Scene\nfrom tesserax.color import Colors\n\n# 1. Setup the static scene\nwith Canvas() as canvas:\n    rect = Square(40, fill=Colors.Orange)\n\ncanvas.fit(10)\n\n# 2. Animate\nscene = Scene(canvas, fps=30)\n\n# We manually drive the loop\nfor i in range(30):\n    rect.rotated(deg(3)) # Rotate 3 degrees per frame\n    scene.capture()      # Snap!\n\n# 3. Render\nscene.display()"
  },
  {
    "objectID": "animations.html#declarative-animations",
    "href": "animations.html#declarative-animations",
    "title": "Animation & Video",
    "section": "Declarative Animations",
    "text": "Declarative Animations\nWhile manual loops are powerful, they get messy quickly. Tesserax provides a declarative API where you define what happens, not how.\nThe Scene.play() method accepts one or more Animation objects.\n\nParallel: Arguments passed to play(a, b) run simultaneously.\nSequential: Animations added with a + b run one after another.\n\nWe use the .animate property on shapes to quickly generate these objects.\n\n\nCode\nfrom tesserax import Circle\n\nwith Canvas() as canvas:\n    box = Square(30, fill=Colors.LightBlue).translated(-40, 0)\n    ball = Circle(15, fill=Colors.Salmon).translated(40, 0)\n\ncanvas.fit(10)\nscene = Scene(canvas, fps=30)\n\n# Define animations\nmove_box = box.animate.rotate(deg(90)) | box.animate.translate(20)\nfade_ball = ball.animate.scale(0.5)\n\n# Run them together (box moves sequentially, ball scales in parallel)\nscene.play(move_box.looping(), fade_ball.looping(), duration=2.0)\n\nscene.display()\n\n\n\n\n\n\nAnimation Modifiers\nYou can tweak the timing and behavior of any animation using fluent modifiers:\n\n.reversed(): Plays backwards.\n.looping(): Plays forward then backward (yoyo).\n.repeating(n): Repeats n times within the duration.\n.delayed(t): Waits for t (0.0 to 1.0) before starting.\n.smoothed(): Applies an ease-in-out curve (default is linear).\n\n\n\nCode\nfrom tesserax import Shape\n\nwith Canvas() as c:\n    b1 = Circle(10, fill=Colors.Red).translated(-30, 0)\n    b2 = Circle(10, fill=Colors.Blue).translated(0, 0)\n    b3 = Circle(10, fill=Colors.Green).translated(30, 0)\n\nc.fit(40)\nscene = Scene(c)\n\n# Create a jump animation\ndef jump(shape: Shape):\n    return (\n        shape.animate.translate(0, -40).smoothed() |\n        shape.animate.translate(0, 0).smoothed()\n    )\n\nscene.play(\n    jump(b1),\n    jump(b2).delayed(0.2), # Start 20% later\n    jump(b3).delayed(0.4), # Start 40% later\n    duration=1.5\n)\n\nscene.display()"
  },
  {
    "objectID": "animations.html#morphing-and-warping",
    "href": "animations.html#morphing-and-warping",
    "title": "Animation & Video",
    "section": "Morphing and Warping",
    "text": "Morphing and Warping\nFor Polyline shapes, Tesserax offers advanced vertex manipulation.\n\nMorphing\nThe .morph(target) animation smoothly interpolates the points of one shape into another.\n\n\nCode\nfrom tesserax import Polyline\n\nwith Canvas() as c:\n    # Start as a Triangle\n    shape = Polyline.poly(3, 40, fill=Colors.Gold).subdivide()\n    # Target is a Hexagon\n    target = Polyline.poly(6, 40).hide()\n\nc.fit(10)\nscene = Scene(c)\n\nscene.play(\n    shape.animate.morph(target).smoothed().looping(),\n    duration=2.0\n)\n\nscene.display()\n\n\n\n\n\n\n\nWarping\nThe .warp(func) animation allows you to apply a function to every point in a shape over time. This is perfect for wave effects.\n\n\nCode\nimport math\nfrom tesserax import Point\n\nwith Canvas() as c:\n    # Create a dense line so we have points to warp\n    line = Polyline([Point(x, 0) for x in range(-50, 50, 2)], stroke=Colors.Blue)\n\nc.fit(15)\nscene = Scene(c)\n\n# Define a wave function\ndef wave(p, t):\n    # t goes 0 -&gt; 1\n    # We use it to shift the phase\n    phase = t * math.pi * 2\n    amplitude = 10\n    freq = 0.1\n    return Point(p.x, math.sin(p.x * freq + phase) * amplitude)\n\nscene.play(\n    line.animate.warp(wave).repeating(2),\n    duration=2.0\n)\n\ncanvas.fit(10)\nscene.display()"
  },
  {
    "objectID": "animations.html#text-effects",
    "href": "animations.html#text-effects",
    "title": "Animation & Video",
    "section": "Text Effects",
    "text": "Text Effects\nText objects have their own special animator with effects like write (typewriter style) and scramble (hacker style).\n\n\nCode\nfrom tesserax import Text\n\nwith Canvas() as c:\n    t1 = Text(\"Hello World\", size=24).translated(0, -20)\n    t2 = Text(\"Encryption\", size=24, fill=Colors.Green, font=\"monospace\").translated(0, 20)\n\nc.fit(10)\nscene = Scene(c)\n\nscene.play(\n    t1.animate.write(),\n    t2.animate.scramble(),\n    duration=2.0\n)\nscene.wait(1.0)\n\nscene.display()"
  },
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "Core Concepts & Primitives",
    "section": "",
    "text": "Tesserax is designed to be a “thin layer” of geometric logic over SVG. Unlike plotting libraries that try to decide for you how axes and scales should work, Tesserax gives you a blank canvas and a set of precise drafting tools.\nThis guide covers the fundamental building blocks: the coordinate system, basic shapes, transformations, the anchor system, and the powerful Polyline API."
  },
  {
    "objectID": "core.html#the-canvas-and-coordinates",
    "href": "core.html#the-canvas-and-coordinates",
    "title": "Core Concepts & Primitives",
    "section": "The Canvas and Coordinates",
    "text": "The Canvas and Coordinates\nEvery diagram begins with a Canvas. In Tesserax, the Canvas serves two roles:\n\nContainer: It collects all shapes created within its context.\nViewport: It manages the final SVG bounding box and coordinate mapping.\n\n\nMathematical Coordinate System\nTesserax follows the standard SVG Coordinate System:\n\nThe origin \\((0, 0)\\) is at the top-left corner (initially).\nThe X-axis points to the right (\\(+x\\)).\nThe Y-axis points down (\\(+y\\)).\n\nThis is crucial to remember when applying rotations. A positive rotation (counter-clockwise) moves the \\(+x\\) axis towards the \\(+y\\) axis (downwards on the screen).\n\n\nCode\nfrom tesserax import Canvas, Rect, Text\nfrom tesserax.color import Colors\n\nwith Canvas() as canvas:\n    # A simple reference grid\n    Rect(100, 100, stroke=Colors.LightGray, fill=Colors.White)\n\n    # Origin marker\n    Text(\"(0,0)\", size=20)\n\n    # Positive X/Y indication\n    Text(\"+X\", size=20).translated(70, 0)\n    Text(\"+Y\", size=20).translated(0, 70)\n\ncanvas.fit(5).display()"
  },
  {
    "objectID": "core.html#basic-primitives",
    "href": "core.html#basic-primitives",
    "title": "Core Concepts & Primitives",
    "section": "Basic Primitives",
    "text": "Basic Primitives\nTesserax provides a suite of geometric atoms. All visual shapes inherit from the Visual class, which standardizes properties like fill, stroke, and width.\n\nRectangles and Circles\n\nRect(w, h): Defined by width and height. Centered at by default.\nSquare(size): A convenience wrapper for Rect.\nCircle(r): Defined by radius. Centered at .\nEllipse(rx, ry): Defined by horizontal and vertical radii.\n\n\n\nCode\nfrom tesserax import Canvas, Rect, Square, Circle, Ellipse\n\nwith Canvas() as c:\n    # Shapes are placed at (0,0) by default, so we translate them to separate them.\n    Square(40, fill=Colors.LightBlue).translated(0, 0)\n    Rect(60, 30, fill=Colors.LightGreen).translated(60, 0)\n    Circle(20, fill=Colors.Salmon).translated(120, 0)\n    Ellipse(20, 10, fill=Colors.Plum).translated(170, 0)\n\nc.fit(10).display()\n\n\n\n\n\n\n\n\n\n\n\nText and Alignment\nText in SVG can be tricky due to alignment issues. Tesserax simplifies this by defaulting to center/middle alignment.\nYou can control this via:\n\nanchor: Horizontal alignment (\"start\", \"middle\", \"end\").\nbaseline: Vertical alignment (\"top\", \"middle\", \"bottom\").\n\n\n\nCode\nfrom tesserax import Text, Line, Point\n\nwith Canvas() as c:\n    # Draw a crosshair at the origin to show alignment\n    Line(Point(0, -20), Point(0, 20), stroke=Colors.LightGray)\n    Line(Point(-50, 0), Point(50, 0), stroke=Colors.LightGray)\n\n    # Default Text (Centered)\n    Text(\"Origin\", size=16, fill=Colors.Black)\n\n    # Custom alignment\n    Text(\"Top-Left\", anchor=\"end\", baseline=\"bottom\").translated(-20, -20)\n    Text(\"Bottom-Right\", anchor=\"start\", baseline=\"top\").translated(20, 20)\n\nc.fit(10).display()"
  },
  {
    "objectID": "core.html#the-transformation-model",
    "href": "core.html#the-transformation-model",
    "title": "Core Concepts & Primitives",
    "section": "The Transformation Model",
    "text": "The Transformation Model\nEvery shape in Tesserax carries a Transform object. This defines an Affine Transformation that maps the shape’s local coordinate space to the parent space.\nThe operation order is strict: Scale - Rotate - Translate.\n\nScale: The object is stretched.\nRotate: The object is rotated around the (scaled) origin.\nTranslate: The object is moved to its final position.\n\nTesserax provides a fluent API to chain these operations:\n\n\nCode\nfrom tesserax import Canvas, Rect, deg\n\nwith Canvas() as c:\n    # 1. Create a rectangle at (0,0)\n    r = Rect(50, 30, fill=Colors.LightBlue, stroke=Colors.Blue)\n\n    # 2. Scale it by 1.5x\n    # 3. Rotate it by 45 degrees\n    # 4. Move it to (50, 50)\n    r.scaled(1.5).rotated(deg(45)).translated(50, 50)\n\n    # Show the origin for reference\n    Circle(2, fill=Colors.Red).translated(50, 50)\n\nc.fit(20).display()"
  },
  {
    "objectID": "core.html#the-anchor-system",
    "href": "core.html#the-anchor-system",
    "title": "Core Concepts & Primitives",
    "section": "The Anchor System",
    "text": "The Anchor System\nOne of Tesserax’s most powerful features is semantic anchoring. Because shapes are often nested inside Groups or transformed heavily, calculating the exact coordinate of “the top-right corner of that rotated rectangle” is mathematically tedious.\nThe .anchor(name) method solves this by resolving the local coordinate through the entire transformation stack.\nAvailable anchors: center, top, bottom, left, right, topleft, topright, bottomleft, bottomright.\n\n\nCode\nfrom tesserax import Arrow\n\nwith Canvas() as c:\n    # A generic shape\n    obj = Rect(60, 40, fill=Colors.Honeydew, stroke=Colors.Green)\n    obj.rotated(deg(30)).translated(50, 50)\n\n    # A target point\n    target = Circle(5, fill=Colors.Red).translated(150, 50)\n\n    # Connect the top-right corner of the rotated rect to the target\n    # We don't need to know where \"top-right\" is in global space,\n    # .anchor() calculates it.\n    Arrow(obj.anchor(\"topright\"), target.anchor(\"center\"))\n\nc.fit(20).display()"
  },
  {
    "objectID": "core.html#paths-and-lines",
    "href": "core.html#paths-and-lines",
    "title": "Core Concepts & Primitives",
    "section": "Paths and Lines",
    "text": "Paths and Lines\nFor arbitrary drawing, Tesserax offers both low-level and high-level path tools.\n\nThe Low-Level Path\nThe Path class maps directly to SVG commands (M, L, C, Q, Z).\n\n\nCode\nfrom tesserax import Path\n\nwith Canvas() as c:\n    p = Path(fill=Colors.Transparent, stroke=Colors.Blue, width=2)\n    p.jump_to(0, 0)\n    p.line_to(50, 50)\n    p.quadratic_to(100, 50, 100, 0) # Control point (100,50), End (100,0)\n\nc.fit(10).display()\n\n\n\n\n\n\n\n\n\n\n\nLines and Arrows\nLine and Arrow are specialized paths that connect two points. They support a curvature parameter to create arcs without manually calculating Bezier control points.\n\n\nCode\nfrom tesserax import Line\n\nwith Canvas() as c:\n    start, end = Point(0, 0), Point(100, 0)\n\n    Line(start, end, curvature=0, stroke=Colors.LightGray) # Straight\n    Line(start, end, curvature=0.5, stroke=Colors.Blue)   # Arc Up\n    Arrow(start, end, curvature=-0.5, stroke=Colors.Red)  # Arc Down\n\nc.fit(30).display()"
  },
  {
    "objectID": "core.html#the-polyline-api",
    "href": "core.html#the-polyline-api",
    "title": "Core Concepts & Primitives",
    "section": "The Polyline API",
    "text": "The Polyline API\nThe Polyline is a versatile tool for creating complex polygons, wireframes, and smooth curves. It maintains a list of Point objects and renders them sequentially.\n\nSmoothing and Rounding\nThe smoothness parameter (\\(0\\) to \\(1\\)) automatically converts sharp vertices into rounded corners using quadratic Bezier interpolation.\n\n\nCode\nfrom tesserax import Polyline\n\npts = [Point(0, 0), Point(50, 50), Point(100, 0), Point(150, 50)]\n\nwith Canvas() as c:\n    # Sharp (0.0)\n    Polyline(pts, smoothness=0, stroke=Colors.Black).translated(0, 0)\n\n    # Rounded (0.5)\n    Polyline(pts, smoothness=0.5, stroke=Colors.Blue).translated(0, 60)\n\n    # Fluid (1.0)\n    Polyline(pts, smoothness=1.0, stroke=Colors.Red).translated(0, 120)\n\nc.fit(10).display()\n\n\n\n\n\n\n\n\n\n\n\nProcedural Generation\nThe Polyline class includes powerful methods to procedurally generate and manipulate shapes.\n\nPolyline.poly(n, radius): Creates a regular n-gon (triangle, hexagon, etc.).\n.subdivide(n): Inserts midpoints between every segment, increasing resolution.\n.simplify(tolerance): Removes points that are collinear or redundant.\n.expand(delta): Pushes points away from the origin (inflation).\n.apply(func): Maps a function over every point.\n\n\n\nCode\nimport math\n\nwith Canvas() as c:\n    # 1. Create a Hexagon\n    hex = Polyline.poly(n=6, radius=40, fill=Colors.AliceBlue)\n    hex.translated(50, 50)\n\n    # 2. Create a \"Wobbly\" Circle\n    # Start with a simple polygon, subdivide it to get many vertices,\n    # then apply a noise function to the radius.\n    blob = Polyline.poly(n=8, radius=40, fill=Colors.MistyRose, smoothness=1)\n    blob.subdivide(3) # Increase vertex count 8 -&gt; 16 -&gt; 32 -&gt; 64\n\n    # Apply a wave function to distort it\n    def distort(p: Point) -&gt; Point:\n        # Get angle of point\n        theta = math.atan2(p.y, p.x)\n        # Vary radius based on angle\n        wave = math.sin(theta * 5) * 5\n        return p + p.normalize() * wave\n\n    blob.apply(distort).simplify(0.1)\n    blob.translated(150, 50)\n\n    # 3. Contract/Expand\n    # Useful for creating outlines or offsets\n    base = Polyline.poly(4, 30, stroke=Colors.Black)\n    inner = base.clone().contract(5) # Shrink\n\n    base.translated(250, 50)\n    inner.translated(250, 50)\n\nc.fit(10).display()"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Tesserax: A Lightweight SVG Rendering Library",
    "section": "",
    "text": "Tesserax is a modern Python 3.12 library designed for programmatic SVG generation with a focus on ease of use, layout management, and flexible geometric primitives. It is particularly well-suited for visualizing data structures, algorithms, and technical diagrams."
  },
  {
    "objectID": "index.html#key-features",
    "href": "index.html#key-features",
    "title": "Tesserax: A Lightweight SVG Rendering Library",
    "section": "Key Features",
    "text": "Key Features\n\nDeclarative Layouts: Effortlessly arrange shapes in Row or Column containers with automatic alignment and spacing.\nAnchor System: Connect shapes using semantic anchors like top, bottom, left, right, and center.\nContext Manager Support: Use with statements to group shapes naturally within the code.\nSmart Canvas: Automatically fit the canvas viewport to the content with adjustable padding.\nRich Primitives: Includes Rect, Square, Circle, Ellipse, Line, Arrow, and Path."
  },
  {
    "objectID": "index.html#installation",
    "href": "index.html#installation",
    "title": "Tesserax: A Lightweight SVG Rendering Library",
    "section": "Installation",
    "text": "Installation\nTesserax has zero dependencies (literally). It’s 100% pure Python, and can be easily installed with pip:\npip install tesserax\nOr if you’re one of the cool kids, using uv:\nuv add tesserax\nIf you want support for saving PNG files, install with the export extra:\npip install tesserax[export]"
  },
  {
    "objectID": "index.html#quick-start",
    "href": "index.html#quick-start",
    "title": "Tesserax: A Lightweight SVG Rendering Library",
    "section": "Quick Start",
    "text": "Quick Start\nTo showcase how Tesserax works, we’ll build a small illustration step by step. We will start with a blank canvas and gradually add layers of complexity, from simple text to automated layouts and animations.\n\nStep 1: The Canvas and Text\nFirst, we initialize the Canvas and add the central Text element. The Canvas acts as our root container. By using the with statement, any shape we create is automatically added to the canvas context.\n\n\nCode\nfrom tesserax import Canvas, Text\nfrom tesserax.color import Colors\n\nwith Canvas() as canvas:\n    t = Text(\n        \"tesserax\",\n        size=48,\n        font=\"sans-serif\",\n        fill=Colors.Navy,\n        anchor=\"middle\",\n    )\n\ncanvas.fit().display()\n\n\n\n\n\n\n\n\n\nThe method Canvas.fit() ensures the canvas is centered around the bounding box of the illustration. The display() method is an IPython/Jupyter/Quarto compatible shortcut to automatically include the rendered SVG (in all its beautiful vectorial glory) directly in a notebook. But you can also use Canvas.save() to generate a plain old, boring SVG file on this, and str(canvas) to get the actual SVG code as a plain string.\n\n\nStep 2: Adding Geometric Shapes\nNext, we add a Square and a Circle. At this stage, we create them without specific coordinates; they will naturally overlap at the origin until we arrange them. We can manually translate/rotate/scale them with a fluent interface.\n\n\nCode\nfrom tesserax import Square, Circle\nfrom tesserax.color import Colors\n\nwith canvas:\n    r = Square(30, fill=Colors.Green, stroke=Colors.Transparent).translated(-120, 0)\n    c = Circle(20, fill=Colors.Red, stroke=Colors.Transparent).translated(120, 0)\n\ncanvas.fit().display()\n\n\n\n\n\n\n\n\n\nWe must call Canvas.fit() again to re-center the canvas.\n\n\nStep 3: Distribution with Groups\nWe can arrange these elements more easily with a Group. Groups can be created explicitely and elementes added using Group.add, or automatically using a with Group() statement, or created implicitely with shape + shape. Once created, a Group can organize its inner shapes with align and distribute.\n\n\nCode\nfrom tesserax import Group\n\nwith Canvas() as canvas:\n    with Group() as g:\n        r = Square(30, fill=Colors.Green, stroke=Colors.Transparent)\n        t = Text(\n            \"tesserax\",\n            size=48,\n            font=\"sans-serif\",\n            fill=Colors.Navy,\n            anchor=\"middle\",\n        )\n        c = Circle(20, fill=Colors.Red, stroke=Colors.Transparent)\n\n    g.align(\"horizontal\").distribute(\"horizontal\")\n\ncanvas.fit(10).display()\n\n\n\n\n\n\n\n\n\nGroups can also have a transformation, which is stacked with their childrens’. This allows creating complex hierarchical layouts without ever computing explicit pixel positions.\n\n\nStep 3a: Using Layouts\nAn alternative, automatic way to align and distribute items is to use Layout subclasses. For example, the RowLayout implements the exact same logic we just did manually.\n\n\nCode\nfrom tesserax.layout import RowLayout\n\nwith Canvas() as canvas:\n    with RowLayout() as logo:\n        r = Square(30, fill=Colors.Green, stroke=Colors.Transparent)\n        t = Text(\n            \"tesserax\",\n            size=48,\n            font=\"sans-serif\",\n            fill=Colors.Navy,\n            anchor=\"middle\",\n        )\n        c = Circle(20, fill=Colors.Red, stroke=Colors.Transparent)\n\ncanvas.fit().display()\n\n\n\n\n\n\n\n\n\nLayouts are basically Group subclasses that perform some sort of automatic organization before rendering.\n\n\nStep 4: Adding the Underline\nTo add some flair, we use the semantic anchor system to draw a Polyline that connects the bottom of the square to the bottom of the circle.\n\n\nCode\nfrom tesserax import Polyline\n\nwith canvas:\n    p = Polyline(\n        points=[r.anchor(\"bottom\").dy(10), c.anchor(\"bottom\").dy(10)],\n        smoothness=1.0,\n        stroke=Colors.Black,\n        marker_end=\"arrow\"\n    )\n\ncanvas.fit(5).display()\n\n\n\n\n\n\n\n\n\nThe arrow marker is a default arrow-like shape declared in the canvas, but you can add custom markers using arbitrary shapes, and use them for all lines.\nThe Polyline is a type of Component, a very powerful kind of shape that allows encapsulating and reusing complex drawing logic.\n\n\nStep 5: Making a Squiggly Line\nTo add some fancy squiggles, we will use some of the powerful operations in Polyline. The first is subdivide which creates new points in the mid-point of every segment, recursively. Then other operation is apply which accepts a function to modify each point, and can be used to draw mathematical functions.\n\n\nCode\nimport math\n\np.subdivide(7).apply(\n    lambda p: p.dy(math.sin((p.x / logo.bounds().width * 20 + 5)) * 5)\n)\n\ncanvas.fit(10).display()\n\n\n\n\n\n\n\n\n\nThe Shape.bounds() method computes an axis-align bounding box, in this case, to the whole group that conforms the logo (our previous RowLayout).\n\n\nStep 6: Animating the Logo\nTesserax also has a powerful, declarative animation system. In this example we use a Scene to bring the logo to life. We will rotate the square 90 degrees and make the circle bounce back and forth using a translation loop (using the + operator creates a sequence of animations).\n\n\nCode\nfrom tesserax.animation import Scene\nfrom tesserax import deg\n\nscene = Scene(canvas)\nscene.play(\n    r.animate.rotate(deg(90)),\n    c.animate.translate(-10, 0) | c.animate.translate(0, 0),\n    p.animate.warp(\n        lambda p, t: p.dy(\n            math.sin(p.x / logo.bounds().width * 20 + t * math.pi * 2) * 5\n        )\n    ),\n    duration=1,\n)\n\nscene.display()\n\n\n\n\n\nThe Scene.play method accepts a list of Animation which can be constructed manually or using the Shape.animate fluent API for common animations. As you can see, Scene.display renders the animation to a GIF ready for embedding, but you can also render MP4 videos."
  },
  {
    "objectID": "index.html#core-components",
    "href": "index.html#core-components",
    "title": "Tesserax: A Lightweight SVG Rendering Library",
    "section": "Core Components",
    "text": "Core Components\nTesserax comes with all basic components you need to draw the spectrum of SVG shapes. All shapes support standard SVG attributes like stroke and fill.\n\nRect & Square: Defined by width/height or a single size.\nCircle & Ellipse: Defined by radii.\nGroups: For grouping shapes and applying transforms to them as a single shape.\nArrow: A specialized line that automatically includes an arrowhead marker.\nPath: Supports a fluent API for complex paths using move_to, line_to, cubic_to, and close.\n\n\nLayouts\nLayouts are a unique feature of Tesserax to automate the positioning of child elements. We currently have three layouts, but these are very easy to extend:\n\nRow: Aligns shapes horizontally. Baselines can be set to start, middle, or end.\nColumn: Aligns shapes vertically with start, middle, or end alignment.\nHierarchicalLayout: Useful for drawing trees, DAGs, automata, etc.\nForceLayout: Typically used to draw arbitrary graphs with a force-directed algorithm.\n\n\n\nTransforms\nEvery shape has a Transform object allowing for:\n\nTranslation: shape.translated(dx, dy).\nRotation: shape.rotated(degrees).\nScaling: shape.scaled(factor).\n\nGroups of shapes also have their own transform, and this can be composed ad-infinitum to create complex drawing."
  },
  {
    "objectID": "index.html#why-tesserax",
    "href": "index.html#why-tesserax",
    "title": "Tesserax: A Lightweight SVG Rendering Library",
    "section": "Why Tesserax?",
    "text": "Why Tesserax?\nIn the Python ecosystem, there is a clear divide between data visualization (plotting numbers) and diagrammatic representation (drawing concepts). Tesserax is built for the latter.\nIt is designed for researchers, educators, and authors who need the geometric precision of a professional drafting tool combined with the power of a modern programming language.\n\nTesserax vs. The Alternatives\n\nPrecision over Statistics\nLibraries like Matplotlib, Seaborn, or Altair are designed to map data points to visual encodings (bars, lines, scatter points).\nThe Difference: Tesserax does not compete with these libraries because it does not render data graphs. You wouldn’t use Tesserax to plot a CSV. Instead, Tesserax is for “the rest” of the figures in a paper: the schematics, the geometric proofs, the architectural diagrams, and the algorithmic walkthroughs where exact spatial relationships convey the meaning.\n\n\nControl over Constraints\nMermaid and Graphviz are excellent for quickly rendering flowcharts using “black-box” layout engines.\nThe Difference: These tools sacrifice control for convenience. If you need an arrow to point exactly at the tangent of a rotated ellipse, or a shape to be sized exactly according to a geometric ratio, Mermaid cannot help you. Tesserax is for Scientific Drawing—providing the low-level primitives needed for total layout authority.\n\n\nThe “TikZ for Python” Philosophy\nTikZ is the industry standard for academic figures, but it requires learning a specialized, often cryptic macro language.\nThe Difference: Tesserax brings the “low-level, total-control” philosophy of TikZ into Python 3.12. You get coordinate-invariant precision and semantic anchoring while using Python’s loops, logic, and types. We are building from the bottom up: starting with geometric atoms and moving toward high-level scientific abstractions (like automated neural network architectures or commutative diagrams) that maintain the ability to “drop down” and tweak a single pixel.\n\n\n\nThe SVG Advantage\nWhile TikZ is the gold standard for LaTeX-based PDF generation, it belongs to a “print-first” era. Tesserax leverages SVG (Scalable Vector Graphics) as its native format, offering a portability that TikZ cannot match without significant friction.\n\nNative Web Rendering: Tesserax figures are native SVGs. They render instantly in any browser, remain crisp at any zoom level, and can be embedded directly into HTML or Markdown (via Quarto) without conversion.\nWYSIWYG Portability: Converting TikZ to SVG for blog posts or online journals often results in broken fonts or misaligned elements. Because Tesserax starts with SVG, what you see in your development notebook is exactly what appears in your final PDF and your website.\nAccessibility & Interaction: Unlike static PDFs, Tesserax SVGs can include metadata and ARIA labels for screen readers. Since they are part of the DOM, they can also be styled with CSS or even animated for interactive educational content.\nPerfect Print: SVG is fully convertible to high-quality, vector-perfect PDF, meeting the highest standards for academic journals and book publishing."
  },
  {
    "objectID": "index.html#contribution",
    "href": "index.html#contribution",
    "title": "Tesserax: A Lightweight SVG Rendering Library",
    "section": "Contribution",
    "text": "Contribution\nTesserax is free as in both free beer and free speech. License is MIT.\nContributions are always welcomed! Fork, clone, and submit a pull request."
  }
]